<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小程序登录的正确打开方式</title>
    <link href="/Wechat/Wechat-Login/"/>
    <url>/Wechat/Wechat-Login/</url>
    
    <content type="html"><![CDATA[<h4 id="小程序网络组件"><a href="#小程序网络组件" class="headerlink" title="小程序网络组件"></a>小程序网络组件</h4><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/RequestTask.html">RequestTask</a> <a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html">wx.request(Object object)</a></p><p><strong>RequestTask说明</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/RequestTask.abort.html">RequestTask.abort()</a></td><td>中断请求任务。</td></tr><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/RequestTask.onHeadersReceived.html">RequestTask.onHeadersReceived(function callback)</a></td><td>监听 HTTP Response Header 事件。会比请求完成事件更早。</td></tr><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/RequestTask.offHeadersReceived.html">RequestTask.offHeadersReceived(function callback)</a></td><td>取消监听 HTTP Response Header 事件。</td></tr><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/RequestTask.onChunkReceived.html">RequestTask.onChunkReceived(function callback)</a></td><td>监听 Transfer-Encoding Chunk Received 事件。当接收到新的chunk时触发。</td></tr><tr><td><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/RequestTask.offChunkReceived.html">RequestTask.offChunkReceived(function callback)</a></td><td>取消监听 Transfer-Encoding Chunk Received 事件。</td></tr></tbody></table><p><strong>wx.request(Object object)属性</strong></p><p><em>此处只列比较常用的属性，全部属性请查看<a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html">链接</a>。</em></p><table><thead><tr><th>属性</th><th>类型</th><th>默认值</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>url</td><td>string</td><td></td><td>是</td><td>开发者服务器接口地址</td></tr><tr><td>data</td><td>string&#x2F;object&#x2F;ArrayBuffer</td><td></td><td>否</td><td>请求的参数</td></tr><tr><td>header</td><td>Object</td><td></td><td>否</td><td>设置请求的 header，header 中不能设置 Referer。 <code>content-type</code> 默认为 <code>application/json</code></td></tr><tr><td>timeout</td><td>number</td><td></td><td>否</td><td>超时时间，单位为毫秒</td></tr><tr><td>method</td><td>string</td><td>GET</td><td>否</td><td>HTTP 请求方法</td></tr><tr><td>success</td><td>function</td><td></td><td>否</td><td>接口调用成功的回调函数</td></tr><tr><td>fail</td><td>function</td><td></td><td>否</td><td>接口调用失败的回调函数</td></tr><tr><td>complete</td><td>function</td><td></td><td>否</td><td>接口调用结束的回调函数（调用成功、失败都会执行）哪怕是abort掉的请求！</td></tr></tbody></table><p><strong>总结一下：所有的小程序接口基本上都有两个特征：</strong></p><ol><li><p>参数都是一个对象。便于记忆的同时方便扩展。</p></li><li><p>都有相同的结果处理方式：都有success、fail、complete三个回调属性。</p></li></ol><p><strong>接口执行的各种情况下的errMsg对象介绍。</strong></p><table><thead><tr><th>回调属性</th><th>errMsg对象</th></tr></thead><tbody><tr><td>success</td><td>{errMsg:”request:ok”…}</td></tr><tr><td>fail</td><td>{errMsg:”request:fail “…} 有的系统这个fail后面有个空格，所以要使用这个判断，最好是使用正则表达式。也可以使用indexOf函数，大于-1进行判断。</td></tr><tr><td>abort</td><td>{errMsg:”request:fail abort”…}</td></tr></tbody></table><p>   <strong>示例代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reqTask = wx.<span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-title function_">getApp</span>().<span class="hljs-property">globalData</span>.<span class="hljs-property">api</span>,<br>    <span class="hljs-title function_">success</span>(<span class="hljs-params">res</span>) &#123;<br>      <span class="hljs-keyword">if</span> (res.<span class="hljs-property">errMsg</span> === <span class="hljs-string">&quot;request:ok&quot;</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res&quot;</span>, res);<br>    &#125;,<br>    <span class="hljs-title function_">fail</span>(<span class="hljs-params">err</span>) &#123;<br>      <span class="hljs-comment">// if(err.errMsg.indexOf(&#x27;request:fail&#x27;)&gt;-1) console.log(&#x27;err&#x27;, err);</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^request:fail/i</span>.<span class="hljs-title function_">test</span>(err.<span class="hljs-property">errMsg</span>)) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err&quot;</span>, err);<br>    &#125;,<br>    <span class="hljs-title function_">complete</span>(<span class="hljs-params">res</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resOrErr&quot;</span>, res);<br>    &#125;,<br>  &#125;);<br> <span class="hljs-keyword">const</span> <span class="hljs-title function_">reqTaskOnHeadersReceived</span> = (<span class="hljs-params">headers</span>) =&gt; &#123;<br>    reqTask.<span class="hljs-title function_">offHeadersReceived</span>(reqTaskOnHeadersReceived);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;headers&quot;</span>, headers);<br>    <span class="hljs-comment">// 由于请求还未完全结束，所以我们没办法获得请求的状态码，但是我们可以通过返回的requestBody的长度来进行判断。</span><br>    <span class="hljs-comment">// 两点说明：1. 两个~~可以把字符串数字快速转化为数字。</span><br>    <span class="hljs-comment">// 2. 为什么取小于19，是由于后台返回没有权限的requestBody的时候Content-length为“18”，正常情况下是大于19的。所以具体多少得看一下具体情况。</span><br>    <span class="hljs-keyword">if</span> (~~headers.<span class="hljs-property">header</span>[<span class="hljs-string">&quot;Content-length&quot;</span>] &lt; <span class="hljs-number">19</span>) reqTask.<span class="hljs-title function_">abort</span>();<br>  &#125;;<br>  reqTask.<span class="hljs-title function_">onHeadersReceived</span>(reqTaskOnHeadersReceived);<br></code></pre></td></tr></table></figure><h4 id="小程序登录接口"><a href="#小程序登录接口" class="headerlink" title="小程序登录接口"></a>小程序登录接口</h4><ol><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserProfile.html">wx.getUserProfile(Object object)</a></p><p>获取用户信息。页面产生点击事件（例如 <code>button</code> 上 <code>bindtap</code> 的回调中）后才可调用，每次请求都会弹出授权窗口，用户同意后返回 <code>userInfo</code>。该接口用于替换 <code>wx.getUserInfo</code>，详见 <a href="https://developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801?highLine=login">用户信息接口调整说明</a>。</p></li><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.checkSession.html">wx.checkSession(Object object)</a></p><p>检查登录态是否过期。 通过 wx.login 接口获得的用户登录态拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者只需要调用 wx.checkSession 接口检测当前用户登录态是否有效。</p><p>登录态过期后开发者可以再调用 wx.login 获取新的用户登录态。调用成功说明当前 session_key 未过期，调用失败说明 session_key 已过期。更多使用方法详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">小程序登录</a>。</p></li><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html">wx.login(Object object)</a></p><p>调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户在当前小程序的唯一标识（openid）、微信开放平台帐号下的唯一标识（unionid，若当前小程序已绑定到微信开放平台帐号）及本次登录的会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。更多使用方法详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">小程序登录</a>。</p></li></ol><h4 id="后端登录接口代码实现"><a href="#后端登录接口代码实现" class="headerlink" title="后端登录接口代码实现"></a>后端登录接口代码实现</h4><p><strong>后端使用NodeJS，web框架KOA版本^2.13.4，路由框架@koa&#x2F;router版本^10.1.1，框架request，版本 ^2.88.2，jsonwebtoken用来加密解密token信息，版本^8.5.1</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Router</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@koa/router&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">WeixinAuth</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./lib/koa2-weixin-auth&quot;</span>);<br><span class="hljs-keyword">const</span> jsonwebtoken = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;jsonwebtoken&quot;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><span class="hljs-comment">// 小程序机票信息</span><br><span class="hljs-keyword">const</span> miniProgramAppId = <span class="hljs-string">&quot;*********&quot;</span>;<br><span class="hljs-keyword">const</span> miniProgramAppSecret = <span class="hljs-string">&quot;***********&quot;</span>;<br><span class="hljs-keyword">const</span> weixinAuth = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeixinAuth</span>(miniProgramAppId, miniProgramAppSecret);<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">JWT_SECRET</span> = <span class="hljs-string">&quot;JWTSECRET&quot;</span>;<br><span class="hljs-comment">// 路由中间件需要安装@koa/router</span><br><span class="hljs-comment">// 开启一个带群组的路由</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>  <span class="hljs-attr">prefix</span>: <span class="hljs-string">&quot;/user&quot;</span>,<br>&#125;);<br><span class="hljs-comment">// 这是正规的登陆方法</span><br><span class="hljs-comment">// 添加一个参数，sessionKeyIsValid，代表sessionKey是否还有效</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/weixin-login&quot;</span>, <span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> &#123; code, userInfo, encryptedData, iv, sessionKeyIsValid &#125; =<br>    ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>;<br>   <span class="hljs-comment">// 解析openid</span><br>  <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">await</span> weixinAuth.<span class="hljs-title function_">getAccessToken</span>(code);<br>  userInfo.<span class="hljs-property">openid</span> = token.<span class="hljs-property">data</span>.<span class="hljs-property">openid</span>;<br>  <span class="hljs-comment">// 这里可以自己进行处理，比方说记录到数据库,处理token等</span><br>  <span class="hljs-keyword">let</span> authorizationToken = jsonwebtoken.<span class="hljs-title function_">sign</span>(<br>    &#123; <span class="hljs-attr">name</span>: userInfo.<span class="hljs-property">nickName</span> &#125;,<br>    <span class="hljs-variable constant_">JWT_SECRET</span>,<br>    &#123; <span class="hljs-attr">expiresIn</span>: <span class="hljs-string">&quot;1d&quot;</span> &#125;<br>  );<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(userInfo, &#123; authorizationToken &#125;);<br>  ctx.<span class="hljs-property">status</span> = <span class="hljs-number">200</span>;<br>  ctx.<span class="hljs-property">body</span> = &#123;<br>    <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;ok&quot;</span>,<br>    <span class="hljs-attr">data</span>: userInfo,<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// lib/koa2-weixin-auth.js</span><br><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;querystring&quot;</span>);<br><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;request&quot;</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AccessToken</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">AccessToken</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccessToken</span>(data);<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data;<br>&#125;;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * 检查AccessToken是否有效，检查规则为当前时间和过期时间进行对比</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Examples:</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> * token.isValid();</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">AccessToken</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isValid</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    !!<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">session_key</span> &amp;&amp;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">create_at</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">expires_in</span> * <span class="hljs-number">1000</span><br>  );<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据appid和appsecret创建OAuth接口的构造函数</span><br><span class="hljs-comment"> * 如需跨进程跨机器进行操作，access token需要进行全局维护</span><br><span class="hljs-comment"> * 使用使用token的优先级是：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1. 使用当前缓存的token对象</span><br><span class="hljs-comment"> * 2. 调用开发传入的获取token的异步方法，获得token之后使用（并缓存它）。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Examples:</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> * var OAuth = require(&#x27;oauth&#x27;);</span><br><span class="hljs-comment"> * var api = new OAuth(&#x27;appid&#x27;, &#x27;secret&#x27;);</span><br><span class="hljs-comment"> * ```</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; appid 在公众平台上申请得到的appid</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; appsecret 在公众平台上申请得到的app secret</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Auth</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">appid, appsecret</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">appid</span> = appid;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">appsecret</span> = appsecret;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span> = &#123;&#125;;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">getToken</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">openid</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>[openid];<br>  &#125;;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">saveToken</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">openid, token</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>[openid] = token;<br>  &#125;;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取授权页面的URL地址</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; redirect 授权后要跳转的地址</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; state 开发者可提供的数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; scope 作用范围，值为snsapi_userinfo和snsapi_base，前者用于弹出，后者用于跳转</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Auth</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getAuthorizeURL</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">redirect_uri, scope, state</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;https://open.weixin.qq.com/connect/oauth2/authorize&quot;</span>;<br>    <span class="hljs-keyword">let</span> info = &#123;<br>      <span class="hljs-attr">appid</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">appid</span>,<br>      <span class="hljs-attr">redirect_uri</span>: redirect_uri,<br>      <span class="hljs-attr">scope</span>: scope || <span class="hljs-string">&quot;snsapi_base&quot;</span>,<br>      <span class="hljs-attr">state</span>: state || <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-attr">response_type</span>: <span class="hljs-string">&quot;code&quot;</span>,<br>    &#125;;<br>    <span class="hljs-title function_">resolve</span>(url + <span class="hljs-string">&quot;?&quot;</span> + querystring.<span class="hljs-title function_">stringify</span>(info) + <span class="hljs-string">&quot;#wechat_redirect&quot;</span>);<br>  &#125;);<br>&#125;;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * 处理token，更新过期时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Auth</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">processToken</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>  data.<span class="hljs-property">create_at</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();<br>  <span class="hljs-comment">// 存储token</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">saveToken</span>(data.<span class="hljs-property">openid</span>, data);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">AccessToken</span>(data);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据授权获取到的code，换取access token和openid</span><br><span class="hljs-comment"> * 获取openid之后，可以调用`wechat.API`来获取更多信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; code 授权获取到的code</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Auth</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getAccessToken</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">code</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;https://api.weixin.qq.com/sns/jscode2session&quot;</span>;<br>    <span class="hljs-comment">//由于此框架版本很久没有更新了，此处地址发生了变化，需要修改为以上地址，不然会出现</span><br>    <span class="hljs-comment">//41008错误。这也是没有直接使用框架，引用本地使用的原因。</span><br>    <span class="hljs-comment">// const url = &quot;https://api.weixin.qq.com/sns/oauth2/access_token&quot;;</span><br>    <span class="hljs-keyword">const</span> info = &#123;<br>      <span class="hljs-attr">appid</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">appid</span>,<br>      <span class="hljs-attr">secret</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">appsecret</span>,<br>      <span class="hljs-attr">js_code</span>: code,<br>      <span class="hljs-attr">grant_type</span>: <span class="hljs-string">&quot;authorization_code&quot;</span>,<br>    &#125;;<br>    request.<span class="hljs-title function_">post</span>(url, &#123; <span class="hljs-attr">form</span>: info &#125;, <span class="hljs-function">(<span class="hljs-params">err, res, body</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(body);<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processToken</span>(data));<br>      &#125;<br>    &#125;);<br>  &#125;);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据refresh token，刷新access token，调用getAccessToken后才有效</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; refreshToken refreshToken</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Auth</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">refreshAccessToken</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">refreshToken</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;https://api.weixin.qq.com/sns/oauth2/refresh_token&quot;</span>;<br>    <span class="hljs-keyword">var</span> info = &#123;<br>      <span class="hljs-attr">appid</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">appid</span>,<br>      <span class="hljs-attr">grant_type</span>: <span class="hljs-string">&quot;refresh_token&quot;</span>,<br>      <span class="hljs-attr">refresh_token</span>: refreshToken,<br>    &#125;;<br>    request.<span class="hljs-title function_">post</span>(url, &#123; <span class="hljs-attr">form</span>: info &#125;, <span class="hljs-function">(<span class="hljs-params">err, res, body</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(body);<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processToken</span>(data));<br>      &#125;<br>    &#125;);<br>  &#125;);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据openid，获取用户信息。</span><br><span class="hljs-comment"> * 当access token无效时，自动通过refresh token获取新的access token。然后再获取用户信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object|String</span>&#125; options 传入openid或者参见Options</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Auth</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getUser</span> = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">openid</span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getToken</span>(openid);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;getUser&quot;</span>, data);<br>  <span class="hljs-keyword">if</span> (!data) &#123;<br>    <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>      <span class="hljs-string">&quot;No token for &quot;</span> + options.<span class="hljs-property">openid</span> + <span class="hljs-string">&quot;, please authorize first.&quot;</span><br>    );<br>    error.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;NoOAuthTokenError&quot;</span>;<br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>  <span class="hljs-keyword">const</span> token = <span class="hljs-title class_">AccessToken</span>(data);<br>  <span class="hljs-keyword">var</span> accessToken;<br>  <span class="hljs-keyword">if</span> (token.<span class="hljs-title function_">isValid</span>()) &#123;<br>    accessToken = token.<span class="hljs-property">data</span>.<span class="hljs-property">session_key</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">var</span> newToken = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">refreshAccessToken</span>(token.<span class="hljs-property">data</span>.<span class="hljs-property">refresh_token</span>);<br>    accessToken = newToken.<span class="hljs-property">data</span>.<span class="hljs-property">session_key</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;accessToken&quot;</span>, accessToken);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_getUser</span>(openid, accessToken);<br>&#125;;<br><br><span class="hljs-title class_">Auth</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_getUser</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">openid, accessToken, lang</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;https://api.weixin.qq.com/sns/userinfo&quot;</span>;<br>    <span class="hljs-keyword">const</span> info = &#123;<br>      <span class="hljs-attr">access_token</span>: accessToken,<br>      <span class="hljs-attr">openid</span>: openid,<br>      <span class="hljs-attr">lang</span>: lang || <span class="hljs-string">&quot;zh_CN&quot;</span>,<br>    &#125;;<br>    request.<span class="hljs-title function_">post</span>(url, &#123; <span class="hljs-attr">form</span>: info &#125;, <span class="hljs-function">(<span class="hljs-params">err, res, body</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(body));<br>      &#125;<br>    &#125;);<br>  &#125;);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据code，获取用户信息。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; code 授权获取到的code</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Auth</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getUserByCode</span> = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">code</span>) &#123;<br>  <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAccessToken</span>(code);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUser</span>(token.<span class="hljs-property">data</span>.<span class="hljs-property">openid</span>);<br>&#125;;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Auth</span>;<br></code></pre></td></tr></table></figure><h4 id="小程序端登录代码实现"><a href="#小程序端登录代码实现" class="headerlink" title="小程序端登录代码实现"></a>小程序端登录代码实现</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--pages/index.wxml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-section&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-section__title&quot;</span>&gt;</span>微信登录<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn-area&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>  <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;getUserProfile&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// pages/index.js</span><br><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 页面的初始数据</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">data</span>: &#123;&#125;,<br>  <span class="hljs-comment">// 正确的登录方式</span><br>  <span class="hljs-title function_">getUserProfile</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 推荐使用wx.getUserProfile获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认</span><br>    <span class="hljs-comment">// 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗</span><br>    wx.<span class="hljs-title function_">getUserProfile</span>(&#123;<br>      <span class="hljs-attr">desc</span>: <span class="hljs-string">&quot;用于完善会员资料&quot;</span>, <span class="hljs-comment">// 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写</span><br>      <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> &#123; userInfo, encryptedData, iv &#125; = res;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">requestLoginApi</span> = (<span class="hljs-params">code</span>) =&gt; &#123;<br>          <span class="hljs-comment">// 发起网络请求</span><br>          wx.<span class="hljs-title function_">request</span>(&#123;<br>            <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://localhost:3000/user/weixin-login&quot;</span>,<br>            <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,<br>            <span class="hljs-attr">header</span>: &#123;<br>              <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>,<br>            &#125;,<br>            <span class="hljs-attr">data</span>: &#123;<br>              code,<br>              userInfo,<br>              encryptedData,<br>              iv,<br>            &#125;,<br>            <span class="hljs-title function_">success</span>(<span class="hljs-params">res</span>) &#123;<br>              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求成功&quot;</span>, res.<span class="hljs-property">data</span>);<br>              <span class="hljs-keyword">let</span> token = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">authorizationToken</span>;<br>              wx.<span class="hljs-title function_">setStorageSync</span>(<span class="hljs-string">&quot;token&quot;</span>, token);<br>              <span class="hljs-title function_">onUserLogin</span>(token);<br>              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;authorization&quot;</span>, token);<br>            &#125;,<br>            <span class="hljs-title function_">fail</span>(<span class="hljs-params">err</span>) &#123;<br>              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求异常&quot;</span>, err);<br>            &#125;,<br>          &#125;);<br>        &#125;;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">onUserLogin</span> = (<span class="hljs-params">token</span>) =&gt; &#123;<br>          <span class="hljs-title function_">getApp</span>().<span class="hljs-property">globalData</span>.<span class="hljs-property">token</span> = token;<br>          wx.<span class="hljs-title function_">showToast</span>(&#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;登录成功了&quot;</span>,<br>          &#125;);<br>        &#125;;<br>        <span class="hljs-comment">//必须进行session是否过期检查，不然会出现第一次点击登录，服务器报Illegal Buffer</span><br>        <span class="hljs-comment">//的错误，但是第二次点击登录正常。</span><br>        wx.<span class="hljs-title function_">checkSession</span>(&#123;<br>          <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// session_key 未过期，并且在本生命周期一直有效</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;在登陆中&quot;</span>);<br>            <span class="hljs-keyword">let</span> token = wx.<span class="hljs-title function_">getStorageSync</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>            <span class="hljs-keyword">if</span> (token) <span class="hljs-title function_">onUserLogin</span>(token);<br>          &#125;,<br>          <span class="hljs-attr">fail</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// session_key已经失效，需要重新执行登录流程</span><br>            wx.<span class="hljs-title function_">login</span>(&#123;<br>              <span class="hljs-title function_">success</span>(<span class="hljs-params">res0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (res0.<span class="hljs-property">code</span>) &#123;<br>                  <span class="hljs-title function_">requestLoginApi</span>(res0.<span class="hljs-property">code</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;登录失败!&quot;</span> + res0.<span class="hljs-property">errMsg</span>);<br>                &#125;<br>              &#125;,<br>            &#125;);<br>          &#125;,<br>        &#125;);<br>      &#125;,<br>    &#125;);<br>  &#125;,<br>&#125;);<br><br></code></pre></td></tr></table></figure><h4 id="针对登录代码可以做哪些优化？"><a href="#针对登录代码可以做哪些优化？" class="headerlink" title="针对登录代码可以做哪些优化？"></a>针对登录代码可以做哪些优化？</h4><p>对于一个软件，就代码层面而言，需要追求最基本的几个方面（远不止这些，但是先姑且先做个好这些吧）：</p><ol><li><p>可维护性（maintainability）</p><p>所谓的“维护”无外乎就是修改 bug、修改老的代码、添加新的代码之类的工作。所谓“代码易维护”就是指，在不破坏原有代码设计、不引入新的 bug 的情况下，能够快速地修改或者添加代码。所谓“代码不易维护”就是指，修改或者添加代码需要冒着极大的引入新 bug 的风险，并且需要花费很长的时间才能完成。</p></li><li><p>可读性（readability）</p><p>软件设计大师 Martin Fowler 曾经说过：“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”翻译成中文就是：“任何傻瓜都会编写计算机能理解的代码。好的程序员能够编写人能够理解的代码。”Google 内部甚至专门有个认证就叫作 Readability。只有拿到这个认证的工程师，才有资格在 code review 的时候，批准别人提交代码。可见代码的可读性有多重要，毕竟，代码被阅读的次数远远超过被编写和执行的次数。我们需要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。</p></li><li><p>可扩展性（extensibility）</p><p>可扩展性也是一个评价代码质量非常重要的标准。代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。</p></li><li><p>可复用性（reusability）</p><p>代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。</p></li></ol><p>那么接下来就来优化一下代码吧：</p><h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><p>可以把登录的代码模块化，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// lib/login.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loginWithCallback</span>(<span class="hljs-params">cb</span>) &#123;<br>  <span class="hljs-comment">// 推荐使用wx.getUserProfile获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认</span><br>  <span class="hljs-comment">// 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗</span><br>  wx.<span class="hljs-title function_">getUserProfile</span>(&#123;<br>    <span class="hljs-attr">desc</span>: <span class="hljs-string">&quot;用于完善会员资料&quot;</span>, <span class="hljs-comment">// 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写</span><br>    <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> &#123; userInfo, encryptedData, iv &#125; = res;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">requestLoginApi</span> = (<span class="hljs-params">code</span>) =&gt; &#123;<br>        <span class="hljs-comment">// 发起网络请求</span><br>        wx.<span class="hljs-title function_">request</span>(&#123;<br>          <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://localhost:3000/user/weixin-login&quot;</span>,<br>          <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,<br>          <span class="hljs-attr">header</span>: &#123;<br>            <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>,<br>          &#125;,<br>          <span class="hljs-attr">data</span>: &#123;<br>            code,<br>            userInfo,<br>            encryptedData,<br>            iv,<br>          &#125;,<br>          <span class="hljs-title function_">success</span>(<span class="hljs-params">res</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求成功&quot;</span>, res.<span class="hljs-property">data</span>);<br>            <span class="hljs-keyword">let</span> token = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">authorizationToken</span>;<br>            wx.<span class="hljs-title function_">setStorageSync</span>(<span class="hljs-string">&quot;token&quot;</span>, token);<br>            <span class="hljs-title function_">onUserLogin</span>(token);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;authorization&quot;</span>, token);<br>          &#125;,<br>          <span class="hljs-title function_">fail</span>(<span class="hljs-params">err</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求异常&quot;</span>, err);<br>          &#125;,<br>        &#125;);<br>      &#125;;<br><br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">onUserLogin</span> = (<span class="hljs-params">token</span>) =&gt; &#123;<br>        <span class="hljs-title function_">getApp</span>().<span class="hljs-property">globalData</span>.<span class="hljs-property">token</span> = token;<br>        wx.<span class="hljs-title function_">showToast</span>(&#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;登录成功了&quot;</span>,<br>        &#125;);<br>        <span class="hljs-keyword">if</span> (cb &amp;&amp; <span class="hljs-keyword">typeof</span> cb == <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-title function_">cb</span>(token);<br>      &#125;;<br>      wx.<span class="hljs-title function_">checkSession</span>(&#123;<br>        <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">// session_key 未过期，并且在本生命周期一直有效</span><br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;在登陆中&quot;</span>);<br>          <span class="hljs-keyword">let</span> token = wx.<span class="hljs-title function_">getStorageSync</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>          <span class="hljs-keyword">if</span> (token) <span class="hljs-title function_">onUserLogin</span>(token);<br>        &#125;,<br>        <span class="hljs-attr">fail</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">// session_key已经失效，需要重新执行登录流程</span><br>          wx.<span class="hljs-title function_">login</span>(&#123;<br>            <span class="hljs-title function_">success</span>(<span class="hljs-params">res0</span>) &#123;<br>              <span class="hljs-keyword">if</span> (res0.<span class="hljs-property">code</span>) &#123;<br>                <span class="hljs-title function_">requestLoginApi</span>(res0.<span class="hljs-property">code</span>);<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;登录失败!&quot;</span> + res0.<span class="hljs-property">errMsg</span>);<br>              &#125;<br>            &#125;,<br>          &#125;);<br>        &#125;,<br>      &#125;);<br>    &#125;,<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> loginWithCallback;<br></code></pre></td></tr></table></figure><h5 id="Promise化"><a href="#Promise化" class="headerlink" title="Promise化"></a>Promise化</h5><p>回调地狱问题，不利于代码的阅读，所以接下来我们基于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>进行代码优化。有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p><p><strong>Promise的几个方法简介</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">Promise.prototype.then</a></td><td>方法返回的是一个新的 Promise 对象，因此可以采用链式写法。这种设计使得嵌套的异步操作，可以被很容易得改写，从回调函数的”横向发展”改为”向下发展”。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch">Promise.prototype.catch</a></td><td>是 Promise.prototype.then(null, rejection) 的别名，用于指定发生错误时的回调函数。Promise 对象的错误具有”冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally">Promise.prototype.finally</a></td><td>方法返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在<code>Promise</code>是否成功完成后都需要执行的代码提供了一种方式。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">Promise.all</a></td><td>这避免了同样的语句需要在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"><code>then()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>catch()</code></a>中各写一次的情况。Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。Promise.all 方法接受一个数组作为参数，<code>var p = Promise.all([p1,p2,p3]);</code>p1、p2、p3 都是 Promise 对象的实例。（Promise.all 方法的参数不一定是数组，但是必须具有 iterator 接口，且返回的每个成员都是 Promise 实例。）p 的状态由 p1、p2、p3 决定，分成两种情况。  （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">Promise.race</a></td><td>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。<code>var p = Promise.race([p1,p2,p3]);</code>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any">Promise.any</a></td><td>接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。所有子实例都处于rejected状态，总的promise才处于rejected状态。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled">Promise.allSettled</a></td><td>返回一个在所有给定的promise都已经<code>fulfilled</code>或<code>rejected</code>后的promise，并带有一个对象数组，每个对象表示对应的promise结果。相比之下，<code>Promise.all()</code> 更适合彼此相互依赖或者在其中任何一个<code>reject</code>时立即结束。</td></tr></tbody></table><h5 id="小程序API接口Promise化并且把需要登录的调用接口模块化"><a href="#小程序API接口Promise化并且把需要登录的调用接口模块化" class="headerlink" title="小程序API接口Promise化并且把需要登录的调用接口模块化"></a>小程序API接口Promise化并且把需要登录的调用接口模块化</h5><ol><li>安装插件。请先查看<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/npm.html">npm支持</a>文档。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save miniprogram-api-promise<br></code></pre></td></tr></table></figure><ol start="2"><li>在微信开发者工具右方详情中勾选使用npm模块，并在菜单栏工具中点击构建npm。</li><li>初始化代码。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">import</span> &#123;promisifyAll&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;miniprogram-api-promise&#x27;</span><br><span class="hljs-keyword">import</span> login <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../lib/login&quot;</span>;<br><span class="hljs-keyword">const</span> wxp =&#123;&#125;<br><span class="hljs-title function_">promisifyAll</span>(wx,wxp)<br><span class="hljs-comment">// 需要token的请求统一处理登录和设置header，并且处理错误信息</span><br>wxp.<span class="hljs-property">requestNeedLogin</span> = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<br>  <span class="hljs-keyword">let</span> token = wx.<span class="hljs-title function_">getStorageSync</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!token) &#123;<br>    token = <span class="hljs-keyword">await</span> <span class="hljs-title function_">loginWithPromise</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!args.<span class="hljs-property">header</span>) args.<span class="hljs-property">header</span> = &#123;&#125;;<br>  args.<span class="hljs-property">header</span>[<span class="hljs-string">&quot;Authorization&quot;</span>] = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span>;<br>  <span class="hljs-keyword">return</span> wxp.<span class="hljs-title function_">request</span>(args).<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);<br>&#125;;<br><span class="hljs-comment">// app.js</span><br><span class="hljs-title class_">App</span>(&#123;<br>  <span class="hljs-attr">wxp</span>:wxp,<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="4"><li>改写login.js代码</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// lib/login.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">login</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 推荐使用wx.getUserProfile获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认</span><br>    <span class="hljs-comment">// 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗</span><br>    wx.<span class="hljs-title function_">getUserProfile</span>(&#123;<br>      <span class="hljs-attr">desc</span>: <span class="hljs-string">&quot;用于完善会员资料&quot;</span>, <span class="hljs-comment">// 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写</span><br>       <span class="hljs-attr">success</span>:<span class="hljs-keyword">async</span> (res0) =&gt; &#123;<br>        <span class="hljs-keyword">let</span> &#123;<br>          userInfo,<br>          encryptedData,<br>          iv<br>        &#125; = res0;<br>        <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">getApp</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>          app.<span class="hljs-property">wxp</span>.<span class="hljs-title function_">checkSession</span>();<br>        &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>          <span class="hljs-title function_">reject</span>(err);<br>        &#125;<br>        <span class="hljs-keyword">let</span> token = wx.<span class="hljs-title function_">getStorageSync</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!token) &#123;<br>          <span class="hljs-keyword">let</span> res1 = <span class="hljs-keyword">await</span> app.<span class="hljs-property">wxp</span>.<span class="hljs-title function_">login</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">reject</span>(err));<br>          <span class="hljs-keyword">let</span> code = res1.<span class="hljs-property">code</span>;<br>          <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> app.<span class="hljs-property">wxp</span>.<span class="hljs-title function_">request</span>(&#123;<br>            <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://localhost:3000/user/weixin-login&quot;</span>,<br>            <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,<br>            <span class="hljs-attr">header</span>: &#123;<br>              <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>,<br>            &#125;,<br>            <span class="hljs-attr">data</span>: &#123;<br>              code,<br>              userInfo,<br>              encryptedData,<br>              iv,<br>            &#125;<br>          &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">reject</span>(err));<br>          token = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">authorizationToken</span>;<br>          wx.<span class="hljs-title function_">setStorageSync</span>(<span class="hljs-string">&quot;token&quot;</span>, token);<br>          app.<span class="hljs-property">globalData</span>.<span class="hljs-property">token</span> = token;<br>          wx.<span class="hljs-title function_">showToast</span>(&#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;登录成功了&quot;</span>,<br>          &#125;);<br>          <span class="hljs-title function_">resolve</span>(token);<br>        &#125;<br>      &#125;,<br>    &#125;);<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> login;<br></code></pre></td></tr></table></figure><ol start="5"><li>调用代码</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container page-head&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-section__title&quot;</span>&gt;</span>需要登录的请求调用<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn-area&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;request1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>请求1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;request2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>请求2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// pages/index.js</span><br><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 页面的初始数据</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">data</span>: &#123;&#125;,<br>  <span class="hljs-title function_">request1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">getApp</span>().<span class="hljs-property">wxp</span>.<span class="hljs-title function_">requestNeedLogin</span>(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://localhost:3000/user/home?name=andying&quot;</span>,<br>      &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)<br>  &#125;,<br>  <span class="hljs-title function_">request2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">getApp</span>().<span class="hljs-property">wxp</span>.<span class="hljs-title function_">requestNeedLogin</span>(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://localhost:3000/user/home?name=eva&quot;</span>,<br>      &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Wechat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>登录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序Icon图标的几个实现方案</title>
    <link href="/Wechat/wechat-icon/"/>
    <url>/Wechat/wechat-icon/</url>
    
    <content type="html"><![CDATA[<h2 id="小程序Icon图标的几种实现方案"><a href="#小程序Icon图标的几种实现方案" class="headerlink" title="小程序Icon图标的几种实现方案"></a>小程序Icon图标的几种实现方案</h2><h3 id="小程序原生提供的Icon组件"><a href="#小程序原生提供的Icon组件" class="headerlink" title="小程序原生提供的Icon组件 "></a>小程序原生提供的<a href="https://developers.weixin.qq.com/miniprogram/dev/component/icon.html">Icon组件 </a></h3><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><table><thead><tr><th>属性</th><th>类型</th><th>默认值</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>string</td><td></td><td>是</td><td>icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear</td></tr><tr><td>size</td><td>number&#x2F;string</td><td>23</td><td>否</td><td>icon的大小</td></tr><tr><td>color</td><td>string</td><td></td><td>否</td><td>icon的颜色，同css的color</td></tr></tbody></table><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><h6 id="组件size属性的长度单位默认为px，2-4-0起支持传入单位-rpx-x2F-px"><a href="#组件size属性的长度单位默认为px，2-4-0起支持传入单位-rpx-x2F-px" class="headerlink" title="组件size属性的长度单位默认为px，2.4.0起支持传入单位(rpx&#x2F;px)"></a>组件size属性的长度单位默认为px，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.4.0</a>起支持传入单位(rpx&#x2F;px)</h6><ol><li>PX 数值类型，默认使用，什么单位都不填，只写一个数值就可以</li><li>RPX（Responsive Pixel）屏幕自适应单位，他将屏幕分为750个单位，每个单位是1&#x2F;750。</li></ol><img src="https://i.loli.net/2021/11/15/JFTBEusxnKaQ8D4.png" style="zoom:50%;" /><p>比方说：iphone6的屏幕宽度是350px，每个rpx就是0.5px。也就是说如果我们在iphone6机器上将size的值设置为60rpx，他与设置为30或者30px的效果是一样的。</p><h6 id="组件color属性是改变图标所有像素点的颜色"><a href="#组件color属性是改变图标所有像素点的颜色" class="headerlink" title="组件color属性是改变图标所有像素点的颜色"></a>组件color属性是改变图标所有像素点的颜色</h6><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="图标与文本能否放在同一行中？"><a href="#图标与文本能否放在同一行中？" class="headerlink" title="图标与文本能否放在同一行中？"></a>图标与文本能否放在同一行中？</h5><p>可以的，图标本身就是为了更好的布局和更方便使用而诞生的。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size: 17px;margin-top: 20px;&quot;</span>&gt;</span><br>    我是一行文字，<span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;success&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;15&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">icon</span>&gt;</span>我里面包含了图标！<br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="有时候真机上Icon显示空白"><a href="#有时候真机上Icon显示空白" class="headerlink" title="有时候真机上Icon显示空白"></a>有时候真机上Icon显示空白</h5><p>首先此问题肯定不是由于字体文件链接没有加入小程序的安全域名，WXSS加载图片及字体允许外域！如果图标是自定义实现的，要检查一下机型及嵌入的字体文件类型，可能是兼容性引起的，在小程序中推荐使用TTF和WOFF格式的字体。如果使用的是这两种字体，情况依然存在，可以考虑换SVG格式的数据嵌入。</p><h5 id="weui组件库里的icon组件的图标如何取出来，保存在本地？"><a href="#weui组件库里的icon组件的图标如何取出来，保存在本地？" class="headerlink" title="weui组件库里的icon组件的图标如何取出来，保存在本地？"></a>weui组件库里的icon组件的图标如何取出来，保存在本地？</h5><p>直接可以打开<a href="https://weui.io/">weui官网</a>，然后通过浏览器开发者工具查看源码，找到资源地址然后下载。或者在<a href="https://developers.weixin.qq.com/miniprogram/design/#%E5%9B%BE%E6%A0%87">微信的官方文档上下载</a>。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>开箱即用。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>只支持success, success_no_circle, info, warn, waiting, cancel, download, search, clear这几种类型，远远不能满足开发需求。</p><h3 id="自定义实现图标"><a href="#自定义实现图标" class="headerlink" title="自定义实现图标"></a>自定义实现图标</h3><h4 id="直接使用图片"><a href="#直接使用图片" class="headerlink" title="直接使用图片"></a>直接使用图片</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>简单粗暴，每个图标对应一个图片。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ol><li>图片在文本中不方便布局。不方便修改颜色。</li><li>图片不能升缩，放大之后会变虚、有锯齿。</li><li>图片需要在本地或者网络上存储，这样将导致大量HTTP请求，使得页面加载速度变慢。</li><li>使用起来不如图标只使用一个名称那么方便。</li></ol><h4 id="使用精灵图"><a href="#使用精灵图" class="headerlink" title="使用精灵图"></a>使用精灵图</h4><p>Sprite，连续图片集，以非重叠、最小化分布的方式排列成一张图片。每次使用的时候通过纵横显示的起始坐标及区域大小，以达到动态切换的效果。</p><img src="https://i.loli.net/2021/11/15/7BH5gdkbLynrfM3.png" alt="2" style="zoom: 33%;" /><h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p>通过精灵图实现一个爆炸效果。图片大小为（650x650） px；所以每一个小图标大小为（130x130）px；这是css样式设置的width和height为130px的原因，也是js代码移动step设置为130的原因。js中left和top均为负数，这是由于这里不是显示图标的坐标，而是背景图片所要向左上方移动的距离。</p><p><strong>注意：在wxss中只可以使用网络图片，不能使用本地图片！</strong></p><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--icon.wxml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sprite scale&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-position: &#123;&#123;left&#125;&#125; &#123;&#123;top&#125;&#125;;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">icon</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* icon.wxss */</span><br><span class="hljs-selector-class">.sprite</span>&#123;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">130px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">130px</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;https://i.loli.net/2021/11/15/7BH5gdkbLynrfM3.png&quot;</span>) no-repeat;<br>&#125;<br><span class="hljs-selector-class">.scale</span>&#123;<br>    <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// icon.js</span><br><span class="hljs-title class_">Page</span>(&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 页面的初始数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">left</span>:<span class="hljs-string">&#x27;0px&#x27;</span>,<br>        <span class="hljs-attr">top</span>:<span class="hljs-string">&#x27;0px&#x27;</span>,<br>    &#125;,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生命周期函数--监听页面加载</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-attr">onLoad</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">var</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">var</span> top = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> step = <span class="hljs-number">130</span>;<br>        <span class="hljs-keyword">const</span> stop = (<span class="hljs-number">650</span>-<span class="hljs-number">130</span>);<br>        <span class="hljs-keyword">var</span> i = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>             <span class="hljs-keyword">if</span> (left &gt;= stop &amp;&amp; top &gt;=stop) &#123;<br>                  <span class="hljs-built_in">clearInterval</span>(i)<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                left += step;<br>                <span class="hljs-keyword">if</span>(left &gt;= <span class="hljs-number">650</span>)&#123;<br>                    left = <span class="hljs-number">0</span>;<br>                    top += step;<br>                &#125;<br>                that.<span class="hljs-title function_">setData</span>(&#123;<br>                    <span class="hljs-attr">left</span>: <span class="hljs-string">&#x27;-&#x27;</span> + left +<span class="hljs-string">&#x27;px&#x27;</span>,<br>                    <span class="hljs-attr">top</span>: <span class="hljs-string">&#x27;-&#x27;</span> + top +<span class="hljs-string">&#x27;px&#x27;</span><br>                  &#125;)<br>             &#125;<br>        &#125;, <span class="hljs-number">100</span>)<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ol><li>在加载的时候，只加载一次。减少了HTTP请求。</li></ol><h4 id="使用CSS样式绘制"><a href="#使用CSS样式绘制" class="headerlink" title="使用CSS样式绘制"></a>使用CSS样式绘制</h4><h5 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-close&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">icon</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.icon-close</span>&#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">17px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">2px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>);<br>&#125;<br><span class="hljs-selector-class">.icon-close</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">17px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">2px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(-<span class="hljs-number">90deg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ol><li>每个图标都需要写CSS样式代码，劳动量大。</li><li>这种图标不是字符，每个图标在绘制时要统一一个中心点，不然使用起来控制位置会比较麻烦。</li><li>大小与颜色也不方便控制。所以这并不是一种好的图标方案。</li></ol><h4 id="使用矢量字体-（推荐使用）"><a href="#使用矢量字体-（推荐使用）" class="headerlink" title="使用矢量字体 （推荐使用）"></a>使用矢量字体 （推荐使用）</h4><p>当浏览器渲染一个字符的时候，首先看font-family样式，确定使用字体名是哪一个。接着以此字符的Unicode在字体文件里查找对应的字符信息。</p><p>字体类型有两种，一种是点阵字体，一种是矢量字体。现在使用最广泛的是矢量字体。矢量字体大概分成三类：Adobe主导的Type1、Apple和Microsoft主导的TrueType、Adobe，Apple和Microsoft共同主导的开源字体OpenType。</p><p>在矢量字体里面每个Unicode只是每个字符的一个索引，每个字符描述信息是一个几何矢量绘图描述信息。以Type1为例，它使用三次贝塞尔曲线来绘制字形。TrueType则使用二次贝塞尔曲线描述字形。正是由于矢量字体是绘制出来的，所以它可以实时填充任何颜色，并且可以无极缩放而没有锯齿。</p><p><a href="https://iconfont.cn/">阿里巴巴的图标网站</a>，我们可以在此网站上搜索到任何图片在线编辑，并下载样式文件，在小程序里面使用。</p><p>字体源说明：</p><ol><li>EOT是微软IE浏览器专用的OpenType字体类型。</li><li>TTF是TrueType字体。</li><li>WOFF与WOFF2是移动开发专用的矢量字体格式。是对三种矢量字体格式的再封装。</li></ol><p>链接各种字体文件源可以兼容不同浏览器宿主环境。浏览器会选择自己支持的格式，从列表中的第一个开始尝试加载。一旦获得一个可以使用的，就不会再加载剩下的字体格式了。小程序里面建议使用TTF和WOFF这两个格式。WOFF2在低版本的IOS设备上会有不兼容的问题。</p><h5 id="使用示例可以参考此文章"><a href="#使用示例可以参考此文章" class="headerlink" title="使用示例可以参考此文章"></a>使用示例可以参考<a href="https://www.jianshu.com/p/25db60f77531">此文章</a></h5><h4 id="使用SVG矢量文件"><a href="#使用SVG矢量文件" class="headerlink" title="使用SVG矢量文件"></a>使用SVG矢量文件</h4><p>很多作图软件都可以导出SVG格式的矢量文件，比方说<a href="https://www.sketch.com/">Sketch</a>，但是它导出的SVG格式的矢量文件有没有用的垃圾信息。可以到<a href="https://iconfont.cn/">阿里巴巴的图标网站</a>编辑好之后下载SVG格式的矢量文件，它不带什么垃圾信息。然后我们拿这个文件找一个Image2base64工具，将文件内容转化为base64的字符串。然后就可以在小程序里使用这个base64的字符串作为图片源，实现自定义图标了。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ol><li>准备SVG图片</li></ol><p><svg t="1636971106558" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1338" width="200" height="200"><path d="M326.2 429.7L710 428 525.4 892.1z" fill="#83A4FF" p-id="1339"></path><path d="M370.2 271.1l292.4 2.6 51.7 113-379.5-2.6z" fill="#FF7E71" p-id="1340"></path><path d="M296.1 380.7L64.9 284.1l124.2-92.3 148.4 76.7z" fill="#A4BEFF" p-id="1341"></path><path d="M64.9 330.5L284 428l235.5 460.6zM755.6 427.1L960.9 321 528.8 886z" fill="#5B79FB" p-id="1342"></path><path d="M751.3 379.8l-57.8-119 132-73.4 113.8 95.8z" fill="#A4BEFF" p-id="1343"></path><path d="M365.8 233.4l-50-12.9-94-52.7 110.4-39.6h360.6l109.5 45.7-105.2 50.9-35.4 8.6z" fill="#C7D8FF" p-id="1344"></path></svg></p><ol start="2"><li><p>使用<a href="https://www.sojson.com/image2base64.html">线上Image2base64</a>转换图片为：</p><figure class="highlight svg"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs svg">data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjM2OTcwNTk4NjAyIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjI2MDAiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNMzI2LjIgNDI5LjdMNzEwIDQyOCA1MjUuNCA4OTIuMXoiIGZpbGw9IiM4M0E0RkYiIHAtaWQ9IjI2MDEiPjwvcGF0aD48cGF0aCBkPSJNMzcwLjIgMjcxLjFsMjkyLjQgMi42IDUxLjcgMTEzLTM3OS41LTIuNnoiIGZpbGw9IiNGRjdFNzEiIHAtaWQ9IjI2MDIiPjwvcGF0aD48cGF0aCBkPSJNMjk2LjEgMzgwLjdMNjQuOSAyODQuMWwxMjQuMi05Mi4zIDE0OC40IDc2Ljd6IiBmaWxsPSIjQTRCRUZGIiBwLWlkPSIyNjAzIj48L3BhdGg+PHBhdGggZD0iTTY0LjkgMzMwLjVMMjg0IDQyOGwyMzUuNSA0NjAuNnpNNzU1LjYgNDI3LjFMOTYwLjkgMzIxIDUyOC44IDg4NnoiIGZpbGw9IiM1Qjc5RkIiIHAtaWQ9IjI2MDQiPjwvcGF0aD48cGF0aCBkPSJNNzUxLjMgMzc5LjhsLTU3LjgtMTE5IDEzMi03My40IDExMy44IDk1Ljh6IiBmaWxsPSIjQTRCRUZGIiBwLWlkPSIyNjA1Ij48L3BhdGg+PHBhdGggZD0iTTM2NS44IDIzMy40bC01MC0xMi45LTk0LTUyLjcgMTEwLjQtMzkuNmgzNjAuNmwxMDkuNSA0NS43LTEwNS4yIDUwLjktMzUuNCA4LjZ6IiBmaWxsPSIjQzdEOEZGIiBwLWlkPSIyNjA2Ij48L3BhdGg+PC9zdmc+<br></code></pre></td></tr></table></figure><ol start="3"><li>编写代码</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.svg-icon</span>&#123;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;  <br>    <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjM2OTcwNTk4NjAyIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjI2MDAiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNMzI2LjIgNDI5LjdMNzEwIDQyOCA1MjUuNCA4OTIuMXoiIGZpbGw9IiM4M0E0RkYiIHAtaWQ9IjI2MDEiPjwvcGF0aD48cGF0aCBkPSJNMzcwLjIgMjcxLjFsMjkyLjQgMi42IDUxLjcgMTEzLTM3OS41LTIuNnoiIGZpbGw9IiNGRjdFNzEiIHAtaWQ9IjI2MDIiPjwvcGF0aD48cGF0aCBkPSJNMjk2LjEgMzgwLjdMNjQuOSAyODQuMWwxMjQuMi05Mi4zIDE0OC40IDc2Ljd6IiBmaWxsPSIjQTRCRUZGIiBwLWlkPSIyNjAzIj48L3BhdGg+PHBhdGggZD0iTTY0LjkgMzMwLjVMMjg0IDQyOGwyMzUuNSA0NjAuNnpNNzU1LjYgNDI3LjFMOTYwLjkgMzIxIDUyOC44IDg4NnoiIGZpbGw9IiM1Qjc5RkIiIHAtaWQ9IjI2MDQiPjwvcGF0aD48cGF0aCBkPSJNNzUxLjMgMzc5LjhsLTU3LjgtMTE5IDEzMi03My40IDExMy44IDk1Ljh6IiBmaWxsPSIjQTRCRUZGIiBwLWlkPSIyNjA1Ij48L3BhdGg+PHBhdGggZD0iTTM2NS44IDIzMy40bC01MC0xMi45LTk0LTUyLjcgMTEwLjQtMzkuNmgzNjAuNmwxMDkuNSA0NS43LTEwNS4yIDUwLjktMzUuNCA4LjZ6IiBmaWxsPSIjQzdEOEZGIiBwLWlkPSIyNjA2Ij48L3BhdGg+PC9zdmc+&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">icon</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;svg-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">icon</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>此种方法仍旧需要一张图片处理一次，然后在页面中引用。注意：样式文件中的width和height属性的值需要和下载的SVG文件的width和height保持一致的（在svg标签中可以看到）。</p></li></ol><h4 id="使用Canvas绘制SVG绘制"><a href="#使用Canvas绘制SVG绘制" class="headerlink" title="使用Canvas绘制SVG绘制"></a>使用Canvas绘制SVG绘制</h4><p>这种绘制用于制作动画还是可以的，但是用来做图标有点大材小用了。<a href="https://developers.weixin.qq.com/community/develop/article/doc/000ca493bc09c0d03a8827b9b5b013">腾讯的将SVG绘制成图像的 Cax 引擎</a></p>]]></content>
    
    
    <categories>
      
      <category>Wechat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Icon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务的基本概念</title>
    <link href="/Spring/Transaction-Basic/"/>
    <url>/Spring/Transaction-Basic/</url>
    
    <content type="html"><![CDATA[<h4 id="定义事务的属性"><a href="#定义事务的属性" class="headerlink" title="定义事务的属性"></a>定义事务的属性</h4><p>在spring中,声明式事务是通过事务属性来定义的.事务属性描述了事务策略如何应用到方法上.事务属性包含了5个方面,如下图所示:</p><p><img src="/Spring/Transaction-Basic/%E4%BA%8B%E7%89%A9%E7%9A%84%E5%B1%9E%E6%80%A7.png" alt="事物的属性"></p><h5 id="事务的传播行为-Propagation"><a href="#事务的传播行为-Propagation" class="headerlink" title="事务的传播行为(Propagation)"></a>事务的传播行为(Propagation)</h5><p>传播行为定义了客户端与被调用方法之间的事务边界,她简单的回答了这样一个问题,即新的事务应该被启动还是被挂起,或者方法是否要在事务环境下运行.</p><p>spring定义了以下传播规则供选择,在org.springframework.transaction.TransactionDefinition中:</p><p><img src="/Spring/Transaction-Basic/%E4%BA%8B%E7%89%A9%E7%9A%84%E4%BC%A0%E9%80%92%E6%83%85%E5%86%B5.png" alt="事物的传递情况"></p><h5 id="隔离级别-Isolation"><a href="#隔离级别-Isolation" class="headerlink" title="隔离级别(Isolation)"></a>隔离级别(Isolation)</h5><p>隔离级别定义了一个事务可能受到其他并发事务的影响程度.也就是事务对事务性数据的自私程度.</p><ol><li>脏读(Dirty reads):发生在一个事务读取了另一个事务改写但尚未提交的数据时.如果改写在稍后被回滚了,那么第一个事务获取的数据就是无效的.</li><li>不可重复读(Nonrepeatable read):发生在一个事务执行相同的查询两次或两次以上,但是每次都得到不同的数据时.通常是因为另一个并发事务在两次查询期间更新了数据.</li><li>幻读(Phantom read):她与不可重复读类似.发生在一个事务(T1)读取了几行数据,接着另一个并发事务(T2)插入了一些数据时.在随后的查询中,第一个事务就会发现多了一些原本不存在的记录.</li></ol><p>在理想的情况下,事务之间是完全隔离的,从而可以防止这些问题的发生.但是完全隔离会导致性能问题.因为他通常涉及锁定数据库中的记录.侵占性的锁定会阻碍并发性,要求事务互相等待以完成各自的工作.考虑到这些问题,spring定义了以下隔离级别,在org.springframework.transaction.TransactionDefinition中:</p><p><img src="/Spring/Transaction-Basic/%E4%BA%8B%E7%89%A9%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png" alt="事物的隔离级别"></p><p>并不是所有的数据源都支持表中的隔离级别,需要查阅你的资源管理器文档来确定哪些隔离级别是可用的.</p><h5 id="只读-Read-Only"><a href="#只读-Read-Only" class="headerlink" title="只读(Read-Only)"></a>只读(Read-Only)</h5><p>声明式事务的第三个特性是他是否为只读事务.如果事务只对后端的数据进行读操作,数据可以利用事务的只读特性来进行一些特定的优化.通过将事务设置为只读,你就可以给数据库一个机会,让他应用他认为合适的优化措施.</p><p>因为只读优化是在事务启动的时候由数据库实施的,只有对那些具备启动一个新的事务的传播行为(PROPAGATION_REQUIRED,PROPAGATION_REQUIRES_NEW,PROPAGATION_NESTED)的方法来说,将事务声明为只读才有意义.</p><p>另外,如果采用Hibernate作为持久化机制,那么将事务声明为只读会导致Hibernate的flush模式被设置为FLUSH_NEVER.这会告诉Hibernate避免和数据库进行不必要的对象同步,并将所有的更新延迟到事务结束.</p><h5 id="事务超时-TimeOut"><a href="#事务超时-TimeOut" class="headerlink" title="事务超时(TimeOut)"></a>事务超时(TimeOut)</h5><p>为了使应用程序很好的运行,事务不能运行太长的时间.假设事务的运行时间变得特别长,因为事务可能涉及对后端数据库的锁定,所以长时间的事务会不必要的占用数据库资源.你可以声明一个事务,在特定的秒数后自动回滚,而不是等待其结束.</p><p>因为超时时钟会在事务开始时启动,所以只有对那些具备启动一个新的事务的传播行为(PROPAGATION_REQUIRED,PROPAGATION_REQUIRES_NEW,PROPAGATION_NESTED)的方法来说,将事务声明超时才有意义.</p><h5 id="回滚规则-Rollback-Rules"><a href="#回滚规则-Rollback-Rules" class="headerlink" title="回滚规则(Rollback Rules)"></a>回滚规则(Rollback Rules)</h5><p>这些规则定义了哪些异常会导致事务回滚而哪些不会.默认情况下,事务只有遇到运行期异常时才会回滚,而在遇到检查型异常时不会回滚.但是你可以声明事务在遇到特定的检查异常时像遇到运行期异常那样回滚.同样,你可以声明事务遇到特定的异常不回滚,即使这些异常是运行期异常.</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Transaction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单的docker应用栈</title>
    <link href="/Docker/Simple-Docker-Stack/"/>
    <url>/Docker/Simple-Docker-Stack/</url>
    
    <content type="html"><![CDATA[<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/Docker/Simple-Docker-Stack/%E6%9E%B6%E6%9E%84.png" alt="架构"></p><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs">说明：这个应用栈包括6个节点，其中包括一个代理节点，两个web应用节点，一个主数据库节点，两个从数据节点。<br></code></pre></td></tr></table></figure><h3 id="实验环境说明"><a href="#实验环境说明" class="headerlink" title="实验环境说明"></a>实验环境说明</h3><p>宿主机操作系统：centos7</p><p>容器<a href="https://www.docker.com/">Docker</a></p><p>代理和负载均衡<a href="http://www.haproxy.com/">HAPoxy</a></p><p>数据库<a href="http://redis.io/">Radis</a></p><p>编程语言<a href="https://www.python.org/">Python</a></p><p>应用框架<a href="https://www.djangoproject.com/">Django</a></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="获取应用栈各节点所需的镜像"><a href="#获取应用栈各节点所需的镜像" class="headerlink" title="获取应用栈各节点所需的镜像"></a>获取应用栈各节点所需的镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull django<br><br>docker pull haproxy<br><br>docker pull redis<br></code></pre></td></tr></table></figure><h4 id="验证docker下载完情况：键入docker-images"><a href="#验证docker下载完情况：键入docker-images" class="headerlink" title="验证docker下载完情况：键入docker images"></a>验证<em>docker</em>下载完情况：键入<strong>docker images</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>django              latest              2427265c139d        2 weeks ago         450.7 MB<br>redis               latest              fb46ec1d66e0        2 weeks ago         151.3 MB<br>haproxy             latest              4e2769f9caad        2 weeks ago         139.1 MB<br></code></pre></td></tr></table></figure><h3 id="应用栈容器节点启动"><a href="#应用栈容器节点启动" class="headerlink" title="应用栈容器节点启动"></a>应用栈容器节点启动</h3><h4 id="启动Redis容器"><a href="#启动Redis容器" class="headerlink" title="启动Redis容器"></a>启动Redis容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --name redis-master redis /bin/bash<br><br>docker run -it --name redis-slave1 --<span class="hljs-built_in">link</span> redis-master:master redis /bin/bash<br><br>docker run -it --name redis-slave2 --<span class="hljs-built_in">link</span> redis-master:master redis /bin/bash<br></code></pre></td></tr></table></figure><h4 id="启动Django应用"><a href="#启动Django应用" class="headerlink" title="启动Django应用"></a>启动Django应用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --name APP1 --<span class="hljs-built_in">link</span> redis-master:db -v ~/Projects/Django/App1:/usr/src/app django /bin/bash<br><br>docker run -it --name APP2 --<span class="hljs-built_in">link</span> redis-master:db -v ~/Projects/Django/App2:/usr/src/app django /bin/bash<br></code></pre></td></tr></table></figure><h4 id="启动HAProxy容器"><a href="#启动HAProxy容器" class="headerlink" title="启动HAProxy容器"></a>启动HAProxy容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run  -it --name HAProxy --<span class="hljs-built_in">link</span> APP1:APP1 --<span class="hljs-built_in">link</span> APP2:APP2 -p 6301:6301 -v ~/Projects/HAProxy:/tmp haproxy /bin/bash<br></code></pre></td></tr></table></figure><h4 id="检查容器运行情况，键入docker-ps"><a href="#检查容器运行情况，键入docker-ps" class="headerlink" title="检查容器运行情况，键入docker ps"></a>检查容器运行情况，键入<strong>docker ps</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES<br>91d571100cee        haproxy             <span class="hljs-string">&quot;/bin/bash&quot;</span>              4 days ago          Up 2 days           0.0.0.0:6301-&gt;6301/tcp   HAProxy<br>894c4241f595        django              <span class="hljs-string">&quot;/bin/bash&quot;</span>              4 days ago          Up 2 days                                    APP2<br>e4d6d2f394cb        django              <span class="hljs-string">&quot;/bin/bash&quot;</span>              4 days ago          Up 2 days                                    APP1<br>84aa1adf394b        redis               <span class="hljs-string">&quot;/entrypoint.sh /bin/&quot;</span>   6 days ago          Up 2 days           6379/tcp                 redis-slave2<br>f71b9c1874a0        redis               <span class="hljs-string">&quot;/entrypoint.sh /bin/&quot;</span>   6 days ago          Up 2 days           6379/tcp                 redis-slave1<br>bf5d59eea503        redis               <span class="hljs-string">&quot;/entrypoint.sh /bin/&quot;</span>   6 days ago          Up 2 days           6379/tcp                 redis-master<br></code></pre></td></tr></table></figure><h3 id="应用栈容器节点的配置"><a href="#应用栈容器节点的配置" class="headerlink" title="应用栈容器节点的配置"></a>应用栈容器节点的配置</h3><h4 id="Redis-Master主数据容器节点的配置"><a href="#Redis-Master主数据容器节点的配置" class="headerlink" title="Redis Master主数据容器节点的配置"></a>Redis Master主数据容器节点的配置</h4><h5 id="配置redis-master节点"><a href="#配置redis-master节点" class="headerlink" title="配置redis master节点"></a>配置redis master节点</h5><ol><li>使用<strong>docker inspect redis-master</strong>命令查看容器所挂载<em>volume</em>的情况。在输出的内容中找到<em>Mounts</em>节点，中的<em>Source</em>的值就是<em>docker</em>机在宿主机的挂载点，形如：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">   <span class="hljs-string">&quot;Mounts&quot;</span>: [<br>&#123;<br>   <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;d8f67be0124d5f0bad604c60214b4b2e6bbb2296f8d08804ea1d2a1c7cce2b49&quot;</span>,<br>   <span class="hljs-string">&quot;Source&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/d8f67be0124d5f0bad604c60214b4b2e6bbb2296f8d08804ea1d2a1c7cce2b49/_data&quot;</span>,<br>   <span class="hljs-string">&quot;Destination&quot;</span>: <span class="hljs-string">&quot;/data&quot;</span>,<br>   <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>   <span class="hljs-string">&quot;Mode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>   <span class="hljs-string">&quot;RW&quot;</span>: <span class="hljs-literal">true</span>,<br>   <span class="hljs-string">&quot;Propagation&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>],<br></code></pre></td></tr></table></figure><p>使用<em>cd</em>命令进入这个目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/d8f67be0124d5f0bad604c60214b4b2e6bbb2296f8d08804ea1d2a1c7cce2b49/_data <br><br>vim redis.conf<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">daemonize <span class="hljs-built_in">yes</span><br>pidfile /var/run/redis.pid<br></code></pre></td></tr></table></figure><ol start="2"><li>进入redis-master容器，利用配置文件启动redis：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it redis-master bash    <br></code></pre></td></tr></table></figure><p>键入<strong>ls</strong>命令可以看到redis－master当前目录有了我们刚才编辑的redis.conf文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> redis.conf /usr/local/bin<br><br><span class="hljs-built_in">cd</span> /usr/local/bin<br><br>redis-server redis.conf<br></code></pre></td></tr></table></figure><ol start="3"><li>同样的方法配置redis-slave*容器，只是这两个redis.conf文件稍微有点不一样。内容如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">daemonize <span class="hljs-built_in">yes</span><br>pidfile /var/run/redis.pid<br>slaveof master 6379<br></code></pre></td></tr></table></figure><h5 id="Redis数据库容器节点测试"><a href="#Redis数据库容器节点测试" class="headerlink" title="Redis数据库容器节点测试"></a>Redis数据库容器节点测试</h5><p>首先使用<strong>docker exec</strong>命令登录<em>redis-master</em>容器，启动<em>redis</em>客户端，并存储一个数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@bf5d59eea503:/data<span class="hljs-comment"># redis-cli</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> master helloworld<br>OK<br>127.0.0.1:6379&gt; get master<br><span class="hljs-string">&quot;helloworld&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure><p>再使用<strong>docker exec</strong>命令登录<em>redis-slave</em>容器，启动<em>redis</em>客户端，获取存储数据：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@84aa1adf394b:/data<span class="hljs-comment"># redis-cli</span><br>127.0.0.1:6379&gt; get master<br><span class="hljs-string">&quot;helloworld&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure><p>证明redis数据库节点已经搭建好了</p><h4 id="APP容器节点的配置"><a href="#APP容器节点的配置" class="headerlink" title="APP容器节点的配置"></a>APP容器节点的配置</h4><p>Django容器启动以后，需要利用Django框架，开发一个简单的Web程序。</p><ol><li>为了访问数据库，需要在容器中安装Python语言的Redis支持包，执行如下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install redis<br></code></pre></td></tr></table></figure><p>安装完后执行以下命令测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@e4d6d2f394cb:/<span class="hljs-comment"># python</span><br>Python 3.4.4 (default, Feb 17 2016, 02:50:56)<br>[GCC 4.9.2] on linux<br>Type <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;copyright&quot;</span>, <span class="hljs-string">&quot;credits&quot;</span> or <span class="hljs-string">&quot;license&quot;</span> <span class="hljs-keyword">for</span> more information.<br>&gt;&gt;&gt; import redis<br>&gt;&gt;&gt; <span class="hljs-built_in">print</span>(redis.__file__)<br>/usr/local/lib/python3.4/site-packages/redis/__init__.py<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>看到类似这样的效果表示<strong>python</strong>的<strong>redis</strong>支持包安装好了</p><ol start="2"><li>利用docker exec命令登录到APP的&#x2F;usr&#x2F;src&#x2F;app目录下,创建APP。执行以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/src/app/<br><span class="hljs-built_in">mkdir</span> dockerweb<br><span class="hljs-built_in">cd</span> dockerweb<br>django-admin startproject redisweb<br><span class="hljs-built_in">cd</span> redisweb<br>python manage.py startapp helloworld<br></code></pre></td></tr></table></figure><ol start="3"><li>在宿主机，做如下操作：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Projects/Django/App1<br><span class="hljs-built_in">cd</span> dockerweb/redisweb/helloworld<br>vim views.py<br></code></pre></td></tr></table></figure><p>输入以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><span class="hljs-keyword">import</span> redis<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">request</span>):<br>   <span class="hljs-built_in">str</span>=redis.__file__<br>   <span class="hljs-built_in">str</span>+=<span class="hljs-string">&quot;&lt;br&gt;&quot;</span><br>   r=redis.Redis(host=<span class="hljs-string">&#x27;db&#x27;</span>,port=<span class="hljs-number">6379</span>,db=<span class="hljs-number">0</span>)<br>   info=r.info()<br>   <span class="hljs-built_in">str</span>+=(<span class="hljs-string">&quot;Set Hi &lt;br&gt;&quot;</span>)<br>   r.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;Hi&#x27;</span>,<span class="hljs-string">&#x27;HelloWorld-APP1&#x27;</span>)<br>   <span class="hljs-built_in">str</span>+=(<span class="hljs-string">&quot;Get Hi: %s &lt;br&gt;&quot;</span> % r.get(<span class="hljs-string">&#x27;Hi&#x27;</span>))<br>   <span class="hljs-built_in">str</span>+=(<span class="hljs-string">&quot;Redis info: &lt;br&gt;&quot;</span>)<br>   <span class="hljs-built_in">str</span>+=(<span class="hljs-string">&quot;Key: Info Value&quot;</span>)<br>   <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> info:<br>         <span class="hljs-built_in">str</span>+=(<span class="hljs-string">&quot;%s :%s &lt;br&gt;&quot;</span> % (key,info[key]))<br>   <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-built_in">str</span>)<br></code></pre></td></tr></table></figure><ol start="4"><li>再执行以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Projects/Django/App1/dockerweb/redisweb/redisweb<br>vim setting.py<br></code></pre></td></tr></table></figure><p>在INSTALLED_APPS节点上添加helloworld项目，形如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Application definition</span><br><br>INSTALLED_APPS = [<br>      <span class="hljs-string">&#x27;django.contrib.admin&#x27;</span>,<br>      <span class="hljs-string">&#x27;django.contrib.auth&#x27;</span>,<br>      <span class="hljs-string">&#x27;django.contrib.contenttypes&#x27;</span>,<br>      <span class="hljs-string">&#x27;django.contrib.sessions&#x27;</span>,<br>      <span class="hljs-string">&#x27;django.contrib.messages&#x27;</span>,<br>      <span class="hljs-string">&#x27;django.contrib.staticfiles&#x27;</span>,<br>      <span class="hljs-string">&#x27;helloworld&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure><ol start="5"><li>再vim urls.py，修改urlpatterns节点，引入helloworld项目。形如下：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.conf.urls <span class="hljs-keyword">import</span> url<br><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> helloworld.views <span class="hljs-keyword">import</span> hello<br><br>urlpatterns = [<br>         url(<span class="hljs-string">r&#x27;^admin/&#x27;</span>, admin.site.urls),<br>         url(<span class="hljs-string">r&#x27;^helloworld$&#x27;</span>,hello)<br>]<br></code></pre></td></tr></table></figure><ol start="6"><li>再次利用docker exec命令进入APP1容器中，执行如下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/src/app/dockerweb/redisweb/<br>python manage.py makemigrations<br>python manage.py migrate<br>python manage.py runserver 0.0.0.0:8001<br>最后输出：<br>Performing system checks...<br><br>System check identified no issues (0 silenced).<br>March 02, 2016 - 16:24:08<br>Django version 1.9.2, using settings <span class="hljs-string">&#x27;redisweb.settings&#x27;</span><br>Starting development server at http://0.0.0.0:8001/<br>Quit the server with CONTROL-C.<br></code></pre></td></tr></table></figure><p>至此APP1应用启动完毕，APP2配置基本一样，只是修改<strong>views.py</strong>时，<em>hello</em>函数这句<em>r.set(‘Hi’,’HelloWorld-APP1’)<em>改成**r.set(‘Hi’,’HelloWorld-APP2’)<strong>，最后启动应用时换一下端口，以备后面代理使用。命令<em>python manage.py runserver 0.0.0.0:8001</em>改成</strong>python manage.py runserver 0.0.0.0:8002</em></em></p><h4 id="HAProxy容器节点的配置"><a href="#HAProxy容器节点的配置" class="headerlink" title="HAProxy容器节点的配置"></a>HAProxy容器节点的配置</h4><ol><li>在宿主机上，执行如下过程：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Projects/HAProxy<br>vim haproxy.cfg<br></code></pre></td></tr></table></figure><p>键入如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">global<br><span class="hljs-built_in">log</span> 127.0.0.1 local0 <span class="hljs-comment">#日志输出配置，所有日志都记录在本机，通过local0输出</span><br>maxconn 4096 <span class="hljs-comment">#最大连接数</span><br><span class="hljs-built_in">chroot</span> /usr/local/sbin <span class="hljs-comment">#改变当前工作目录</span><br>daemon <span class="hljs-comment">#以后台方式运行HAProxy</span><br>nbproc 4 <span class="hljs-comment">#启动4个HAProxy实例</span><br>pidfile /usr/local/sbin/haproxy.pid <span class="hljs-comment">#pid文件位置</span><br><br>defaults<br>      <span class="hljs-built_in">log</span> 127.0.0.1 local3<br>      mode http <span class="hljs-comment">#｛tcp｜http｜health｝设定启动实例的协议类型</span><br>      option dontlognull <span class="hljs-comment">#保证HAProxy不记录上级负载均衡发送过来的用于检测状态没有数据的心跳包</span><br>      option redispatch <span class="hljs-comment">#当serverId对应的服务器挂掉后，强制定向到其他的健康服务器</span><br>      retries 2 <span class="hljs-comment">#重试两次连接失败就认为服务器不可用，主要通过后面的check检查</span><br>      maxconn 2000<br>      balance roundrobin <span class="hljs-comment">#负载均衡算法，roundrobin表示轮询，source表示按照IP</span><br>      <span class="hljs-built_in">timeout</span> connect 5000ms<br>      <span class="hljs-built_in">timeout</span> client 50000ms<br>      <span class="hljs-built_in">timeout</span> server 50000ms<br><br>listen redis_proxy<br>         <span class="hljs-built_in">bind</span>  0.0.0.0:6301<br>      stats <span class="hljs-built_in">enable</span><br>      stats uri /haproxy-stats<br>      server APP1 APP1:8001 check inter 2000 rise 2 fall 5<br>      server APP2 APP2:8002 check inter 2000 rise 2 fall 5<br></code></pre></td></tr></table></figure><ol><li>使用docker exec进入HAProxy容器中，执行以下过程：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /tmp/ <br><span class="hljs-built_in">cp</span> haproxy.cfg /usr/local/sbin/<br>haproxy -f haproxy.cfg<br></code></pre></td></tr></table></figure><p>至此完成所有的容器节点的配置！</p><h3 id="应用栈访问测试"><a href="#应用栈访问测试" class="headerlink" title="应用栈访问测试"></a>应用栈访问测试</h3><p>我的宿主机IP地址为172.16.89.129，故在浏览器上输入<a href="http://172.16.89.129:6301/helloworld%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E6%95%88%E6%9E%9C%E3%80%82">http://172.16.89.129:6301/helloworld即可看到效果。</a></p><p><strong>本文标题:</strong><a href="https://ivivisoft.com/2016/03/02/a-docker-application-stack/">简单的docker应用栈</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ简介下</title>
    <link href="/RabbitMQ/RabbitMQ-Intrduce-part-two/"/>
    <url>/RabbitMQ/RabbitMQ-Intrduce-part-two/</url>
    
    <content type="html"><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>在AMQP模型中的队列和其它的消息和任务队列系统非常相似：她们存储用于被应用程序消费的消息。并且和exchange共享一些属性，但是也有自己额外的属性：</p><ul><li>名字（Name）</li><li>持久性（Durable）：当broker重启的时候，队列仍然存活</li><li>互斥性（Exclusive）：只适用于被一个连接使用时，当连接关闭，队列删除</li><li>自动删除（Auto-delete）：当最后一个消费者取消订阅，队列将被删除</li><li>参数（Arguments）： 一些broker使用她来实现附加功能，比如消息TTL</li></ul><p>队列要使用必须先声明，声明一个不存在的队列将创建这个队列，如果声明一个属性和名字与原有队列一样的队列，将不会产生什么影响。如果队列的属性不一样就会使用406码（PRECONDITION_FAILED）抛出一个channel级别的异常。</p><h4 id="队列名字"><a href="#队列名字" class="headerlink" title="队列名字"></a>队列名字</h4><p>应用可以选择一个队列的名字，也可以要broker生成一个队列的名字。队列的名字可以是255个字符的UTF-8。传空字符串给队列的名字参数，broker将产生一个唯一的名字给你的队列。在同一个channel上使用一个空字符串作为队列名参数调用子类的方法可能得到相同的队列名。这是由于channel记住了最新产生的队列名。</p><p>以“amq.”开始的队列名，是留给broker内部使用的保留队列名。以amq.定义一个队列名将获得一个channel级别的异常，异常码为403（ACCESS_REFUSED）</p><h4 id="队列的持久性"><a href="#队列的持久性" class="headerlink" title="队列的持久性"></a>队列的持久性</h4><p>持久化队列会持久化到磁盘上，即使broker重启。会持久化队列叫做临时性队列。不是所有的场景需要队列持久化的。</p><p>持久化队列并不意味着消息也具有持久化的功能。如果一个broker挂了，再起来，持久化队列将重新定义，但是只有持久化的消息会被恢复。</p><h3 id="绑定（Bindings）"><a href="#绑定（Bindings）" class="headerlink" title="绑定（Bindings）"></a>绑定（Bindings）</h3><p>他是exchenge把消息投递到去队列的规则。告诉一个exchange E把消息投递到队列Q，Q被绑定到E上。某些exchange将选择路由key作Bindings。</p><p>使用路由key是为了选择确定的信息发布到绑定的队列。换而言之，路由key的动作就像是一个过滤器。</p><p>比如：</p><ul><li>队列就像你在纽约的目的地</li><li>交换器就像是JFK的机场</li><li>Bindings就是JFK到达目的地的路径，可以有很多路到达这里</li></ul><p>使用这种分层的架构，使不可能的路由场景或者用直接发送到队列非常难实现场景成为可能，并且避免了应用开发人员不得不做的某些重复工作。</p><p>如果AMQP的信息不能投递到任何队列（比如，由于没有bindings到exchange上），她可以删除信息也可以返回给发送者，完全取决于发送者消息属性的设置。</p><h3 id="消费者（Consumers）"><a href="#消费者（Consumers）" class="headerlink" title="消费者（Consumers）"></a>消费者（Consumers）</h3><p>存储的信息是没有用的，除非应用能消费它们，在AMQP 0-9-1模型中，应用消费消息有两种方式：</p><ol><li>有消息就推送给他们（“push API”）</li><li>自己按需拉取消息（“pull API”）</li></ol><p>使用“push API”，应用必须告诉她想从某个特定的队列中消费消息。当她这样做，我们通常说它们注册了一个消费，或者简单的说，他们订阅了一个队列。可能有不止一个的消费者消费每一个队列，也可能有消费者独占一个队列（当她在消费时，排斥其它的所有消费者）。<br>每一个消费者或者叫订阅者，都有一个叫消费标签的东东来标实自己。它可以用来取消订阅消息，消费者标示只能是字符串。</p><h3 id="消息确认（Message-Acknowledgements）"><a href="#消息确认（Message-Acknowledgements）" class="headerlink" title="消息确认（Message Acknowledgements）"></a>消息确认（Message Acknowledgements）</h3><p>消费和处理消息的应用很有可能处理失败或者发生某些冲突。也可能是网络的问题。这些问题导致AMQP的broker什么时候该从队列中移走消息？AMQP规范规定broker有两个选择可以做这个事：</p><ol><li>在broker发送信息给应用之后（可以使用basic.deliver或者basic.get-ok两个AMQP方法）</li><li>应用返回一个确认信息（使用basic.ack的AMQP方法）</li></ol><p>第一种方式叫做自动确认模式，后面一种叫做手动确认模式。在手动确认模式中，应用程序选择何时发送确认信息。可以是在收到消息之后，也可以是保存信息到数据库之后，也可以是所有步骤都执行之后。<br>如果消费者死去而没有发送任何的确认信息，broker将重新发送消息给另一个消费者，或者如果没有一个消费是可用的，broker将一直等待，直到至少有一个消费者注册到相同的队列，他将把消息发送给这个注册者。</p><h4 id="驳回消息"><a href="#驳回消息" class="headerlink" title="驳回消息"></a>驳回消息</h4><p>消费者处理接收的消息，执行过程中可能会失败。消费者可以通过驳回信息的方式告诉broker自己的执行过程失败了。当驳回一个信息时，消费者可以要broker丢弃或者重新加载信息到队列。当只有一个消费者注册在队列上时，<strong>注意不要不合理的驳回产生驳回，再入列，在消费的死循环！</strong></p><h4 id="否定确认信息"><a href="#否定确认信息" class="headerlink" title="否定确认信息"></a>否定确认信息</h4><p>消息可以使用basic.reject的AMQP方法驳回。但是有限制：没有办法驳回已经确认的信息。但是，如果你使用RabbitMQ，将有解决方案，RabbitMQ提供了一个AMQP 0-9-1的去扩展叫否定确认或者叫做否定回答。</p><h4 id="预抓信息"><a href="#预抓信息" class="headerlink" title="预抓信息"></a>预抓信息</h4><p>当多个消费者共享一个队列的时候，指定一个队列在发送下一个确定消息时可以接收多少消息是很有用的。它可以被用作简单的负载均衡技术，或者提高批量消息发布的吞吐量。</p><p><strong>注意：RabbitMQ只提供channel级别的prefetch-count，不提供connection或者基本个数的预抓</strong></p><h3 id="消息的属性和装载量（Message-Attributes-and-Payload）"><a href="#消息的属性和装载量（Message-Attributes-and-Payload）" class="headerlink" title="消息的属性和装载量（Message Attributes and Payload）"></a>消息的属性和装载量（Message Attributes and Payload）</h3><p>AMQP模型的消息有属性，一些普通的属性是AMQP0-9-1明确指定的，开发者没有必要去管他们具体的名字。例如：</p><ul><li>Content-type</li><li>Content encoding</li><li>Routing key</li><li>Delivery mode(persistent or not)</li><li>Message priority</li><li>Message publishing timestamp</li><li>Expriation period</li><li>Publisher application id</li></ul><p>一些属性要被broker用到，一些属性是可选的以header的形式为人所知，就像HTTP里面的X-Header信息。消息属性在消息被发送时被定义。</p><p>AMQP消息也有payload（携带数据的），broker会把他们当成透明的字符数组。她不会修改和监视他们。没有payload只有一些属性的消息是可以存在的。一般采用JSON，Thrift，网关缓存和消息包的方式序列化结构化数据放在payload中。AMQP一般使用content-type和content-encoding字段的值传递与之相关的信息，这两个属性只有在转换的时候才用到。</p><h3 id="连接（Connections）"><a href="#连接（Connections）" class="headerlink" title="连接（Connections）"></a>连接（Connections）</h3><p>AMQP连接一般是长连接，AMQP饰应用级的使用TCP的可靠连接传递信息。连接可以用TLS（SSL）来授权。当连接不在连接broker应该优雅的关闭连接而不是突然的关闭。</p><h3 id="渠道（Channels）"><a href="#渠道（Channels）" class="headerlink" title="渠道（Channels）"></a>渠道（Channels）</h3><p>有些应用需要连接broker的多个连接。但是许多的TCP连接在同一时间被打开，这样会导致系统资源的占用，防火墙也不好配置，因此是不受欢迎的。AMQP0-9-1使用许多channel来共享一个connection的方法，来实现轻量化连接。</p><p>应用使用多个进程或者线程执行程序，一般都开一个新的channel给每一个进程或者线程而不是共享一个channel。</p><p>一个channel的信息是完全和另外的channel是分开的，因此每一个channel 的方法都带了一个叫channel number的，这样客户端就可以知道是哪个channel的方法了。</p><h3 id="虚拟主机（Virtual-Hosts）"><a href="#虚拟主机（Virtual-Hosts）" class="headerlink" title="虚拟主机（Virtual Hosts）"></a>虚拟主机（Virtual Hosts）</h3><p>为了实现一个单一的broker去host多个隔离的环境（用户组，exchanges，queues等等），AMQP引入虚拟host的概念（vhosts）.和许多流行的web服务提供的虚拟host的非常相似，AMQP提供完全的隔离环境以供AMQP实体生存。在与AMQP的connect连接时。AMQP客户端指定怎样的vhost他们想连接</p>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Introduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ简介上</title>
    <link href="/RabbitMQ/RabbitMQ-Intrduce-part-one/"/>
    <url>/RabbitMQ/RabbitMQ-Intrduce-part-one/</url>
    
    <content type="html"><![CDATA[<h3 id="AMQP（Advanced-Message-Queuing-Protocol）公开标准"><a href="#AMQP（Advanced-Message-Queuing-Protocol）公开标准" class="headerlink" title="AMQP（Advanced Message Queuing Protocol）公开标准"></a>AMQP（Advanced Message Queuing Protocol）公开标准</h3><p>解决什么问题</p><ol><li>信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何方式丢失？</li><li>如何降低发送者和接收者的耦合度？</li><li>如何让<strong>Priority</strong>高的接收者先接到数据？</li><li>如何做到<strong>load balance</strong>？有效均衡接收者的负载？</li><li>如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的<strong>filter</strong>？</li><li>如何做到可扩展，甚至将这个通信模块发到<strong>cluster</strong>上？</li><li>如何保证接收者接收到了完整，正确的数据？</li></ol><h3 id="RabbitMQ应用场景"><a href="#RabbitMQ应用场景" class="headerlink" title="RabbitMQ应用场景"></a>RabbitMQ应用场景</h3><p>消息机制，可以使软件应用，支持连接和大规模化。一个应用通过彼此连接的方式，可以作为一个大的应用的组件或者用户设备和信息中心。消息机制通过分离发送数据端和接收数据端，达到系统解藕，以及异步化。</p><p>以下场景你可以使用消息机制：</p><ol><li>数据传输</li><li>非阻塞的操作，异步执行过程</li><li>推送通知</li><li>使用发布／订阅机制</li><li>使用一个工作队列</li></ol><p>RabbitMQ实现了<strong>ANMQP</strong>标准，是一个消息机制的代理人－一个中间人。她是一个应用按照统一的平台来收发消息，并且你的消息会在一个安全的地方存放，除非消息被接收者消费。</p><h3 id="RabbitMQ特性"><a href="#RabbitMQ特性" class="headerlink" title="RabbitMQ特性"></a>RabbitMQ特性</h3><ol><li>可靠性（<strong>Reliability</strong>）：<em>RabbitMQ</em>通过数据持久化，传输ack，发送确认，高可用的特性来保证她的高可靠性。</li><li>可集群（<strong>Clustering</strong>）：通过一个逻辑中间人的形式，许多<em>RabbitMQ</em>的服务在同一的网络可以实现集群。</li><li>灵活路由（<strong>Flexible Routing</strong>）：消息到达消息队列之前可以通过exchanges实现路由，<em>RabbitMQ</em>针对传统的路由逻辑类型，内置了几种消息exchanges类型。处理复杂的路由你可以把这些exhchange绑定使用，甚至可以自己写exchange类型，以插件的方式使用。</li><li>可联盟（<strong>Federation</strong>）：For servers that need to be more loosely and unreliably connected than clustering allows，RabbitMQ提供了联盟模式。</li><li>高可用的队列（<strong>Highly Available Queues</strong>）：队列能在集群中跨机器镜像，从而保证即使一些设备故障，你的信息还是安全的。</li><li>多协议支持（<strong>Multi-protocol</strong>）：提供多协议支持</li><li>多客户端支持（<strong>Many Clients</strong>）： 提供多种语言的客户端支持</li><li>可视化管理（<strong>Management UI</strong>）：提供了简单易用的可视化管理界面管理你的<em>RabbitMQ</em></li><li>可追踪（<strong>Tracing</strong>）：如果你的消息系统出现异常，你可以通过轨迹记录查出问题所在</li><li>插件支持（<strong>Plugin System</strong>）：<em>RabbitMQ</em>提供了许多的插件来按照你自己的方式扩展她。</li></ol><h3 id="RabbitMQ架构"><a href="#RabbitMQ架构" class="headerlink" title="RabbitMQ架构"></a>RabbitMQ架构</h3><p><img src="/RabbitMQ/RabbitMQ-Intrduce-part-one/RabbitMQ%E6%9E%B6%E6%9E%84.png" alt="RabbitMQ架构.png"></p><p>消息被发送者发送到exchange上，然后exchange通过规则（<em>bindings</em>）将消息copy到相应的队列，接下来AMQP代理者将消息发送到订阅队列的消费者上，或者主动从自己需要的消息队列上拉消息。</p><p>当发送一个消息时，发送者会指定一些信息的属性（消息元数据）。一些消息元数据会被代理人（<em>broker</em>）使用，然后剩下来的是对代理人完全透明的（<em>completely opaque</em>），这些只有接收消息的应用才能使用。</p><p>网络是不稳定的，并且应用可能传递消息失败，因此AMQP模型引入了消息确认（<em>message acknowledgements</em>）的概念。当一个消费者接到一个消息，消费者通知代理人，或者自动的，或者一会有应用开发者去选择的通知代理人。代理人通过确认消息已被使用，来从消息队列中完全移掉此消息。</p><p>某些情况，例如当一个消息不能路由到一个消息队列，消息将会返回给消息发送者，删掉，或者代理人实现了扩展，把消息放到一个称之为“死信队列”（dead letter queue）的地方。消息发送者可以通过使用某些确定的参数来决定怎么处理这些情况。</p><p>Queues, exchanges和bindings 都是作为AMQP实体被集体引入进来的概念.</p><h3 id="AMQP是一个可程控的协议"><a href="#AMQP是一个可程控的协议" class="headerlink" title="AMQP是一个可程控的协议"></a>AMQP是一个可程控的协议</h3><p>AMQP 0-9-1是一个在AMQP实体和路由场景的应用中，由应用自己定义的，而不是代理人管理者（<strong>broker</strong>）定义的。因此这样的需求使得它包括了定义队列和定义交换中心（<strong>exchange</strong>），定义他们之间的绑定关系（<strong>bindings</strong>），订阅队列等操作。</p><p>这是的应用开发者许多的自由，但与此同时考虑操作的冲突。实践中发现，定义的冲突经常是由于缺失配置引起的。</p><p>应用定义她们需要的AMQP实体，定义必要的路由场景，并且可能的选择删除那些不再使用的AMQP实体。</p><h3 id="Exchanges和Exchange的类型"><a href="#Exchanges和Exchange的类型" class="headerlink" title="Exchanges和Exchange的类型"></a>Exchanges和Exchange的类型</h3><p>Exchange是当消息发送时的AMQP的实体，她获取发送者的消息，并且将消息路由到0个或者多个队列。使用怎样的路由算法，通过exchange的类型和bindings的规则决定，下面是一些基本的exchange类型：</p><table><thead><tr><th align="left">名字</th><th align="left">默认的指定名字</th></tr></thead><tbody><tr><td align="left">直接交换器（Direct exchange）</td><td align="left">(Empty string)和amq.direct</td></tr><tr><td align="left">扇出交换器（Fanout exchange）</td><td align="left">amq.fanout</td></tr><tr><td align="left">主题订阅交换器（Topic exchange）</td><td align="left">amq.topic</td></tr><tr><td align="left">头交换器（Header exchange）</td><td align="left">amq.match(和amq.headers in RabbitMQ)</td></tr></tbody></table><p>除了有这些交换器类型，交换器还有许多的属性，最重要的有以下这些：</p><ul><li>名字（Name）</li><li>持久性（Durability）：broker重启时，交换器还存活着</li><li>自动删除（Auto-delete）：当队列已经全部使用完，交换器自己删除</li><li>参数（Arguments）：这些代理人要使用</li></ul><h4 id="默认交换器"><a href="#默认交换器" class="headerlink" title="默认交换器"></a>默认交换器</h4><p>她是直接交换器，他有一个特别的属性使得她针对于简单的应用十分有用：每一个创建的队列是自动绑定一个和队列名字一样的路由key。例如：当你用“<em>search-indexing-online</em>”的名字定义了一个队列，AMQP代理者将使用“<em>search-indexing-online</em>”作为路由key绑定默认的交换器。因此一个消息使用这个路由key发送到默认的交换器，他将被存储到名字为“<em>search-indexing-online</em>”的队列。也就是说，直接交换器给人一种直接将消息发送到消息队列的感觉，虽然技术上不是这样实现的。</p><h4 id="直接交换器"><a href="#直接交换器" class="headerlink" title="直接交换器"></a>直接交换器</h4><p>她是一种通过路由key将消息传递到队列中的一种交换器。她是单播传递信息的理想选择，尽管他也可以多播。</p><h5 id="工作的机制"><a href="#工作的机制" class="headerlink" title="工作的机制"></a>工作的机制</h5><ol><li>一个队列通过路由key K绑定在交换器上</li><li>当一个新的携带路由key R的消息到达直接交换器上，如果K ＝ R，她将信息传递</li></ol><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>她经常使用在多个作业者（相同应用的实现）之间以轮循的方式分发任务。当这样使用的时候，理解在AMQP中负载均衡发生在消费者中而不是队列中是很重要的！</p><h5 id="怎样生动的表示"><a href="#怎样生动的表示" class="headerlink" title="怎样生动的表示"></a>怎样生动的表示</h5><p><img src="/RabbitMQ/RabbitMQ-Intrduce-part-one/%E7%9B%B4%E6%8E%A5%E4%BA%A4%E6%8D%A2%E8%B7%AF%E7%94%B1.png" alt="直接交换路由"></p><h4 id="扇出交换器"><a href="#扇出交换器" class="headerlink" title="扇出交换器"></a>扇出交换器</h4><p>她直接投递消息到所有绑定在她身上的队列，并且忽略路由key。她是广播消息的理想选择。</p><h5 id="工作的机制-1"><a href="#工作的机制-1" class="headerlink" title="工作的机制"></a>工作的机制</h5><ol><li>N个队列绑定在某个扇出交换器上</li><li>当一个消息发送到这个交换器上，这个消息将被投递到这N个队列上</li></ol><h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li>大规模的多个在线玩家的游戏可以用它来更新积分榜或者其它的全局事件</li><li>体育新闻网站可以用它来发布分数给所有的手机客户端，几乎是实时的</li><li>分布式系统可以用它来广播各种状态和配置信息</li><li>群聊中可以用它来发布信息给所有参与者（尽管AMQP协议没有对这一块的规定，所以这种场景下，使用即时通信协议（XMPP）可能是最好的选择）</li></ol><h5 id="怎样生动的表示-1"><a href="#怎样生动的表示-1" class="headerlink" title="怎样生动的表示"></a>怎样生动的表示</h5><p><img src="/RabbitMQ/RabbitMQ-Intrduce-part-one/fanout%E4%BA%A4%E6%8D%A2%E8%B7%AF%E7%94%B1.png" alt="fanout交换路由"></p><h4 id="主题交换器"><a href="#主题交换器" class="headerlink" title="主题交换器"></a>主题交换器</h4><p>她通过匹配一个路由key或者路由key的正则表达式，来讲消息发送到绑定在此交换器上的一个队列上。她通常用来实现各种多变的发布和订阅关系。她通常使用多播方式投递信息。她的使用场景很广，任何一个涉及到多个消费者和应用，并且她们要自己选择消息主题去接收消息的问题，都可以考虑使用主题交换器。</p><h5 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li>分布数据与特定的地理位置,例如,销售点</li><li>多个工作者处理的后台任务，每一个工作者处理特定一系列任务能力</li><li>股票价格的更新（也可以更新某一类财政数据）</li><li>按照某个类别和标签更新新闻（例如：仅仅是特定的运动或者运动对）</li><li>在云上精心编排的各种服务</li><li>分布式架构／特定的系统 的软件，当每一个构建者只能兼容一个架构或者某一个系统的构建或者打包</li></ol><h4 id="头交换器"><a href="#头交换器" class="headerlink" title="头交换器"></a>头交换器</h4><p>她是设计用来投递许多属性以头信息的方式更容易投递。而不是以路由key的方式。头交换器忽略路由key属性。取而代之的是，使用头信息里的属性。当头信息里header的值等于绑定的值，认为信息符合。</p><p>这可能绑定一个队列到一个头交换器使用多个header匹配。这样的话代理者就需要额外的信息来确定是要全部匹配还是当个匹配，有一个叫“x-match”的属性，如果你设置为any，就仅仅需要一个header值被匹配就可以了。当这个设置为all，则需要所有的header都被匹配才可以。</p><p>头交换器可以看作为直接交换器在类固醇上。因为他是靠头信息值来路由的，这可以认为是没有使用空值作为路由key的直接交换器。例如它可以是一个整形值或者一个hash值。</p>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Introduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOSQL数据库</title>
    <link href="/Database/NoSQL-Database/"/>
    <url>/Database/NoSQL-Database/</url>
    
    <content type="html"><![CDATA[<h3 id="关系型数据库与NOSQL之争"><a href="#关系型数据库与NOSQL之争" class="headerlink" title="关系型数据库与NOSQL之争"></a>关系型数据库与NOSQL之争</h3><p>在过去几年，关系型数据库一直是数据持久化的唯一选择，数据工作者考虑的也只是在这些传统数据库中做筛选，比如SQL Server、Oracle或者是MySQL。甚至是做一些默认的选择，比如使用.NET的一般会选择SQL Server；使用Java的可能会偏向Oracle，Ruby是MySQL，Python则是PostgreSQL或MySQL等等。</p><p>原因很简单：过去很长一段时间内，关系数据库的健壮性已经在多数应用程序中得到证实。我们可以使用这些传统数据库良好的控制并发操作、事务等等。然而如果传统的关系型数据库一直这么可靠，那么还有NoSQL什么事？NoSQL之所以生存并得到发展，是因为它做到了传统关系型数据库做不到的事！</p><h4 id="关系型数据库中存在的问题"><a href="#关系型数据库中存在的问题" class="headerlink" title="关系型数据库中存在的问题"></a>关系型数据库中存在的问题</h4><p><img src="/Database/NoSQL-Database/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98.jpeg" alt="关系型数据库中存在的问题"></p><p>我们使用Python、Ruby、Java、.Net等语言编写应用程序，这些语言有一个共同的特性——面向对象。但是我们使用MySQL、PostgreSQL、Oracle以及SQL Server，这些数据库同样有一个共同的特性——关系型数据库。这里就牵扯到了“Impedance Mismatch”这个术语：存储结构是面向对象的，但是数据库却是关系的，所以在每次存储或者查询数据时，我们都需要做转换。类似Hibernate、Entity Framework这样的ORM框架确实可以简化这个过程，但是在对查询有高性能需求时，这些ORM框架就捉襟见肘了。</p><h4 id="应用程序规模的变大"><a href="#应用程序规模的变大" class="headerlink" title="应用程序规模的变大"></a>应用程序规模的变大</h4><p>网络应用程序的规模日渐变大，我们需要储存更多的数据、服务更多的用户以及需求更多的计算能力。为了应对这种情形，我们需要不停的扩展。扩展分为两类：一种是纵向扩展，即购买更好的机器，更多的磁盘、更多的内存等等；另一种是横向扩展，即购买更多的机器组成集群。在巨大的规模下，纵向扩展发挥的作用并不是很大。首先单机器性能提升需要巨额的开销并且有着性能的上限，在Google和Facebook这种规模下，永远不可能使用一台机器支撑所有的负载。鉴于这种情况，我们需要新的数据库，因为关系数据库并不能很好的运行在集群上。不错你也可能会去搭建关系数据库集群，但是他们使用的是共享存储，这并不是我们想要的类型。于是就有了以Google、Facebook、Amazon这些试图处理更多传输所引领的NoSQL纪元。</p><h3 id="NoSQL纪元"><a href="#NoSQL纪元" class="headerlink" title="NoSQL纪元"></a>NoSQL纪元</h3><p>当下已经存在很多的NoSQL数据库，比如MongoDB、Redis、Riak、HBase、Cassandra等等。每一个都拥有以下几个特性中的一个：</p><ul><li>不再使用SQL语言，比如MongoDB、Cassandra就有自己的查询语言</li><li>通常是开源项目</li><li>为集群运行而生</li><li>弱结构化——不会严格的限制数据结构类型</li></ul><h4 id="NoSQL数据库的类型"><a href="#NoSQL数据库的类型" class="headerlink" title="NoSQL数据库的类型"></a>NoSQL数据库的类型</h4><p>NoSQL可以大体上分为4个种类：Key-value、Document-Oriented、Column-Family Databases以及 Graph-Oriented Databases。下面就一览这些类型的特性：</p><h5 id="键值（Key-Value）数据库"><a href="#键值（Key-Value）数据库" class="headerlink" title="键值（Key-Value）数据库"></a>键值（Key-Value）数据库</h5><p>键值数据库就像在传统语言中使用的哈希表。你可以通过key来添加、查询或者删除数据，鉴于使用主键访问，所以会获得不错的性能及扩展性。</p><p><strong>产品</strong>：Riak、Redis、Memcached、Amazon’s Dynamo、Project Voldemort</p><p><strong>有谁在使用</strong>：GitHub （Riak）、BestBuy （Riak）、Twitter （Redis和Memcached）、StackOverFlow （Redis）、 Instagram （Redis）、Youtube （Memcached）、Wikipedia（Memcached）</p><p><strong>适用的场景</strong></p><p>储存用户信息，比如会话、配置文件、参数、购物车等等。这些信息一般都和ID（键）挂钩，这种情景下键值数据库是个很好的选择。</p><p><strong>不适用场景</strong></p><ol><li>取代通过键查询，而是通过值来查询。Key-Value数据库中根本没有通过值查询的途径。</li><li>需要储存数据之间的关系。在Key-Value数据库中不能通过两个或以上的键来关联数据。</li><li>事务的支持。在Key-Value数据库中故障产生时不可以进行回滚。</li></ol><h5 id="面向文档（Document-Oriented）数据库"><a href="#面向文档（Document-Oriented）数据库" class="headerlink" title="面向文档（Document-Oriented）数据库"></a>面向文档（Document-Oriented）数据库</h5><p>面向文档数据库会将数据以文档的形式储存。每个文档都是自包含的数据单元，是一系列数据项的集合。每个数据项都有一个名称与对应的值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如有序列表和关联对象。数据存储的最小单位是文档，同一个表中存储的文档属性可以是不同的，数据可以使用XML、JSON或者JSONB等多种形式存储。</p><p><strong>产品</strong>：MongoDB、CouchDB、RavenDB</p><p><strong>有谁在使用</strong>：SAP （MongoDB）、Codecademy （MongoDB）、Foursquare （MongoDB）、NBC News （RavenDB）</p><p><strong>适用的场景</strong></p><ol><li>日志。企业环境下，每个应用程序都有不同的日志信息。Document-Oriented数据库并没有固定的模式，所以我们可以使用它储存不同的信息。</li><li>分析。鉴于它的弱模式结构，不改变模式下就可以储存不同的度量方法及添加新的度量。</li></ol><p><strong>不适用场景</strong></p><p>在不同的文档上添加事务。Document-Oriented数据库并不支持文档间的事务，如果对这方面有需求则不应该选用这个解决方案。</p><h5 id="列存储（Wide-Column-Store-x2F-Column-Family）数据库"><a href="#列存储（Wide-Column-Store-x2F-Column-Family）数据库" class="headerlink" title="列存储（Wide Column Store&#x2F;Column-Family）数据库"></a>列存储（Wide Column Store&#x2F;Column-Family）数据库</h5><p>列存储数据库将数据储存在列族（column family）中，一个列族存储经常被一起查询的相关数据。举个例子，如果我们有一个Person类，我们通常会一起查询他们的姓名和年龄而不是薪资。这种情况下，姓名和年龄就会被放入一个列族中，而薪资则在另一个列族中。</p><p><strong>产品</strong>：Cassandra、HBase</p><p><strong>有谁在使用</strong>：Ebay （Cassandra）、Instagram （Cassandra）、NASA （Cassandra）、Twitter （Cassandra and HBase）、Facebook （HBase）、Yahoo!（HBase）</p><p><strong>适用的场景</strong></p><ol><li>日志。因为我们可以将数据储存在不同的列中，每个应用程序可以将信息写入自己的列族中。</li><li>博客平台。我们储存每个信息到不同的列族中。举个例子，标签可以储存在一个，类别可以在一个，而文章则在另一个。</li></ol><p><strong>不适用场景</strong></p><ol><li>如果我们需要ACID事务。Vassandra就不支持事务。</li><li>原型设计。如果我们分析Cassandra的数据结构，我们就会发现结构是基于我们期望的数据查询方式而定。在模型设计之初，我们根本不可能去预测它的查询方式，而一旦查询方式改变，我们就必须重新设计列族。</li></ol><h5 id="图（Graph-Oriented）数据库"><a href="#图（Graph-Oriented）数据库" class="headerlink" title="图（Graph-Oriented）数据库"></a>图（Graph-Oriented）数据库</h5><p>图数据库允许我们将数据以图的方式储存。实体会被作为顶点，而实体之间的关系则会被作为边。比如我们有三个实体，Steve Jobs、Apple和Next，则会有两个“Founded by”的边将Apple和Next连接到Steve Jobs。</p><p><strong>产品</strong>：Neo4J、Infinite Graph、OrientDB</p><p><strong>有谁在使用</strong>：Adobe （Neo4J）、Cisco （Neo4J）、T-Mobile （Neo4J）</p><p><strong>适用的场景</strong></p><ol><li>在一些关系性强的数据中</li><li>推荐引擎。如果我们将数据以图的形式表现，那么将会非常有益于推荐的制定</li></ol><p><strong>不适用场景</strong></p><p>不适合的数据模型。图数据库的适用范围很小，因为很少有操作涉及到整个图。</p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NOSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三心二意</title>
    <link href="/Life/Mind/"/>
    <url>/Life/Mind/</url>
    
    <content type="html"><![CDATA[<h1 id="三心二意"><a href="#三心二意" class="headerlink" title="三心二意"></a>三心二意</h1><p><strong>所谓三心是指</strong>：初心、进取心、出离心；<br><strong>所谓二意是指</strong>：要有危机意识、精英意识。</p><h2 id="保持初心"><a href="#保持初心" class="headerlink" title="保持初心"></a>保持初心</h2><p>佛家常讲“不忘初心方得始终”，意思是说一个人做事情，不要忘记最初时候的本心，始终如一保持开始的信念，最后就一定能取得成功。</p><h2 id="保持进取心"><a href="#保持进取心" class="headerlink" title="保持进取心"></a>保持进取心</h2><p>进取心是一个人不断成长、不断取得新成绩的直接动力。没有进取心，就很难产生成功的动力，成功就少了支点。进取心不是一心想升职加薪，而是做任何事都会追求更好的心态。或许你会问，整日面对各种琐碎繁杂的工作，激情早就被现实浇灭了，哪来的进取心。但我还是要说，就算是再平凡的工作，总有办法做得比以前好那么一点点。长期坚持，一定会形成质变。而这或许能为你打开更多的门，送你走上更高的台阶。</p><h2 id="保持出离心"><a href="#保持出离心" class="headerlink" title="保持出离心"></a>保持出离心</h2><p>出离心也是一个佛教词汇，是指一种随时可以放下现在执着于一些东西、每时每刻都可以重新开始的勇气。要正确看待，懂得放弃。记得曾经读过一篇文章，大意是讲什么样的员工才是合格的员工，老板的答案有些出乎意料，是那些想着离开的员工。认真分析一下，其实原因简单，只有保持着离开企业的心态的员工，才会更加积极的增强本领，才不会在单位混吃等死。而这些员工，恰恰将会成为企业的脊梁，只要给他舞台，便会大有可为。</p><h2 id="保持危机意识"><a href="#保持危机意识" class="headerlink" title="保持危机意识"></a>保持危机意识</h2><p>抱怨得多、学习得少；空谈得多、实干得少；固守得多、创新得少；抵触得多、开放得少……基本成了我们生活工作的常态。殊不知不学习就会落后、不实干就会退化、不创新就会掉队、不开放就会封闭，企业如此，个人更是如此。保持危机意识不是一句空话，而应当成为运营商人的“达摩克利斯之剑”，长悬头顶，方可战战兢兢、如履薄冰，方可有所敬畏、有所为。</p><h2 id="保持精英意识"><a href="#保持精英意识" class="headerlink" title="保持精英意识"></a>保持精英意识</h2><p>这里的精英意识并不是鼓励我们近乎天然的优越感、满足感，而是指在工作方法、工作心态、工作状态、工作成果等各方面追求卓越的品质。曾经多年积累的优势很可能在一夜之间化为乌有。如果不能以精英的标准要求自己，那么企业和个人的前途都将堪忧。<br>认真问问自己到底想要什么，规划一下如何实现既定目标，从最简单的一件事开始做起哪怕只是列一张清单，都比无谓地吐槽和空想实际地多。<br>任何公司只是一次职业生涯中的路标，未来的路还很遥远。不要再纠结于“该不该”，踏踏实实解决好“能不能”，或许你的选择会更多、更好、更主动。</p><h2 id="放下一切，重新上路吧！"><a href="#放下一切，重新上路吧！" class="headerlink" title="放下一切，重新上路吧！"></a>放下一切，重新上路吧！</h2>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Python实现自己的shell</title>
    <link href="/Python/Make-yourself-shell-by-Python/"/>
    <url>/Python/Make-yourself-shell-by-Python/</url>
    
    <content type="html"><![CDATA[<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="/Python/Make-yourself-shell-by-Python/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="项目结构"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h4><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><pre><code class="hljs python">[shell.py] []<br><span class="hljs-comment"># -*- coding: utf-8 -*-：</span><br><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> shlex<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment">### 导入常量</span><br><span class="hljs-keyword">from</span> ysh.constants <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">### 导入所有内建函数引用</span><br><span class="hljs-keyword">from</span> ysh.builtins.cd <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> ysh.builtins.exit <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-comment">### 注册内建函数到内建命令的哈希映射中</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register_command</span>(<span class="hljs-params">name, func</span>):<br>    built_in_cmds[name] = func<br><br><br><span class="hljs-comment">### 在此注册所有的内建命令</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>():<br>    register_command(<span class="hljs-string">&#x27;cd&#x27;</span>, cd)<br>    register_command(<span class="hljs-string">&#x27;exit&#x27;</span>, exit)<br><br><br><span class="hljs-comment">### 使用哈希映射来存储内建的函数名及其引用</span><br>built_in_cmds = &#123;&#125;<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">shell_loop</span>():<br>    status = SHELL_STATUS_RUN<br>    <span class="hljs-keyword">while</span> status == SHELL_STATUS_RUN:<br>        <span class="hljs-comment">### 显示命令提示符</span><br><br>        sys.stdout.write(<span class="hljs-string">&#x27;$&#x27;</span>+os.getlogin()+<span class="hljs-string">&#x27; &#x27;</span>+os.getcwd() + <span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>        sys.stdout.flush()<br><br>        <span class="hljs-comment">### 读取命令输入</span><br>        cmd = sys.stdin.readline()<br><br>        <span class="hljs-comment">### 切分命令输入</span><br>        cmd_tokens = tokenize(cmd)<br><br>        <span class="hljs-comment">### 执行该命令并获取新的状态</span><br>        status = execute(cmd_tokens)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize</span>(<span class="hljs-params">string</span>):<br>    <span class="hljs-keyword">return</span> shlex.split(string)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">cmd_tokens</span>):<br>    <span class="hljs-comment">###从元组中分拆命令名与参数</span><br>    cmd_name = cmd_tokens[<span class="hljs-number">0</span>]<br>    cmd_args = cmd_tokens[<span class="hljs-number">1</span>:]<br>    <span class="hljs-comment">### 如果该命令是一个内建命令,使用参数调用该函数</span><br>    <span class="hljs-keyword">if</span> cmd_name <span class="hljs-keyword">in</span> built_in_cmds:<br>        <span class="hljs-keyword">return</span> built_in_cmds[cmd_name](cmd_args)<br>    <span class="hljs-comment">### 分叉一个子shell进程</span><br>    <span class="hljs-comment">### 如果当前进程是子进程,期&#x27;pid&#x27;被设置为&#x27;0&#x27;</span><br>    <span class="hljs-comment">### 如果当前进程是父进程,&#x27;pid&#x27;的值是其子进程的进程ID</span><br>    pid = os.fork()<br>    <span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment">###子进程</span><br>        <span class="hljs-comment">###用被exec调用程序替换该子进程</span><br>        os.execvp(cmd_tokens[<span class="hljs-number">0</span>], cmd_tokens)<br>    <span class="hljs-keyword">elif</span> pid &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment">### 父进程</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment">### 等待其子进程的响应状态(以进程ID来查找)</span><br>            wpid, status = os.waitpid(pid, <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">### 当其子进程正常退出时</span><br>            <span class="hljs-comment">### 或者其被信号中断时,结束等待状态</span><br>            <span class="hljs-keyword">if</span> os.WIFEXITED(status) <span class="hljs-keyword">or</span> os.WIFSIGNALED(status):<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-comment">### 返回状态以告知在shell_loop中等待下一个命令</span><br>    <span class="hljs-keyword">return</span> SHELL_STATUS_RUN<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    init()<br>    shell_loop()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">[constants.py] []<span class="hljs-comment"># -*- coding: utf-8 -*-：</span><br><br>SHELL_STATUS_RUN = <span class="hljs-number">1</span><br>SHELL_STATUS_STOP = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h4><p>我们fork了一个子进程去执行命令,执行命令的过程没有发生在父进程上.比如cd命令,这样只是改变了子进程的当前目录,而没有改变父进程的.所以像这种与shell自己相关的命令必须是内置命令.他必须在shell进程中执行,而不是分叉中!</p><ul><li>(cd)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">[cd.py] []<br><span class="hljs-comment"># -*- coding: utf-8 -*-：</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> ysh.constants <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cd</span>(<span class="hljs-params">args</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) == <span class="hljs-number">0</span>:<br>        os.chdir(os.environ[<span class="hljs-string">&#x27;HOME&#x27;</span>])<br>    <span class="hljs-keyword">else</span>:<br>        os.chdir(args[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">return</span> SHELL_STATUS_RUN<br></code></pre></td></tr></table></figure><ul><li>(exit)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">[exit.py] []<br><span class="hljs-comment"># -*- coding: utf-8 -*-：</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> ysh.constants <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exit</span>(<span class="hljs-params">args</span>):<br>    <span class="hljs-keyword">return</span> SHELL_STATUS_STOP<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现简单的RPC(Remote procedure call)</title>
    <link href="/Java/Make-Simple-Remote-procedure-call/"/>
    <url>/Java/Make-Simple-Remote-procedure-call/</url>
    
    <content type="html"><![CDATA[<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/Java/Make-Simple-Remote-procedure-call/%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="整体架构.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="服务接口"><a href="#服务接口" class="headerlink" title="服务接口"></a>服务接口</h4><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs java">[EchoService] []<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EchoService</span> &#123;<br>    String <span class="hljs-title function_">echo</span><span class="hljs-params">(String ping)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务实现"><a href="#服务实现" class="headerlink" title="服务实现"></a>服务实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">[EchoServiceImpl] []<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EchoService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">echo</span><span class="hljs-params">(String ping)</span> &#123;<br>        <span class="hljs-keyword">return</span> ping != <span class="hljs-literal">null</span> ? ping + <span class="hljs-string">&quot; --&gt; I am Ok.&quot;</span> : <span class="hljs-string">&quot;I am Ok.&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务发布者-Exporter"><a href="#服务发布者-Exporter" class="headerlink" title="服务发布者(Exporter)"></a>服务发布者(Exporter)</h4><p>服务发布者<br>主要职责如下:</p><ol><li>作为服务端,监听客户端TCP连接,接收到客户端连接后,将其封装成Task,由线程池执行</li><li>将客户端发送的码流发序列化成对象,反射调用服务实现者,获取执行结果</li><li>将执行结果对象反序列化,通过ocket发送给客户端.</li><li>远程服务调用完成之后,释放Socket等连接资源,防止句柄泄露</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java">[RpcExporter] []<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcExporter</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exporter</span><span class="hljs-params">(String hostname, <span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>();<br>        server.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(hostname, port));<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExporterTask</span>(server.accept()));<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            server.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExporterTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ExporterTask</span><span class="hljs-params">(Socket client)</span> &#123;<br>            <span class="hljs-built_in">this</span>.client = client;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                input = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(client.getInputStream());<br>                <span class="hljs-type">String</span> <span class="hljs-variable">interfaceName</span> <span class="hljs-operator">=</span> input.readUTF();<br>                Class&lt;?&gt; service = Class.forName(interfaceName);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> input.readUTF();<br>                Class&lt;?&gt;[] paramterType = (Class&lt;?&gt;[]) input.readObject();<br>                Object[] arguments = (Object[]) input.readObject();<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> service.getMethod(methodName, paramterType);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(service.newInstance(), arguments);<br>                output = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(client.getOutputStream());<br>                output.writeObject(result);<br><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (output != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        output.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (input != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        input.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (client != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        client.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="本地代理-Importer"><a href="#本地代理-Importer" class="headerlink" title="本地代理(Importer)"></a>本地代理(Importer)</h4><p>本地代理<br>主要职责如下:</p><ol><li><p>将本地的接口调用转换成JDK动态代理,在动态代理中实现接口的远程调用</p></li><li><p>创建Socket客户端,根据指定地址连接远程服务提供者</p></li><li><p>将远程服务端调用所需的接口类,方法名,参数列表等编码后发送给服务提供者</p></li><li><p>同步阻塞等待服务端返回应答,获取应答之后返回</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">[RpcImporter] []<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcImporter</span>&lt;S&gt; &#123;<br>    <span class="hljs-keyword">public</span> S <span class="hljs-title function_">importer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; serviceClass, <span class="hljs-keyword">final</span> InetSocketAddress addr)</span> &#123;<br>        <span class="hljs-keyword">return</span> (S) Proxy.newProxyInstance(serviceClass.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[]&#123;serviceClass.getInterfaces()[<span class="hljs-number">0</span>]&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>();<br>                    socket.connect(addr);<br>                    output = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(socket.getOutputStream());<br>                    output.writeUTF(serviceClass.getName());<br>                    output.writeUTF(method.getName());<br>                    output.writeObject(method.getParameterTypes());<br>                    output.writeObject(args);<br>                    input = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(socket.getInputStream());<br>                    <span class="hljs-keyword">return</span> input.readObject();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span> (socket != <span class="hljs-literal">null</span>) &#123;<br>                        socket.close();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (output != <span class="hljs-literal">null</span>) &#123;<br>                        output.close();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (input != <span class="hljs-literal">null</span>) &#123;<br>                        input.close();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">[RpcTest] []<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//发布服务</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    RpcExporter.exporter(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        RpcImporter&lt;EchoService&gt; importer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcImporter</span>&lt;EchoService&gt;();<br>        <span class="hljs-type">EchoService</span> <span class="hljs-variable">echoService</span> <span class="hljs-operator">=</span> importer.importer(EchoServiceImpl.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        System.out.println(echoService.echo(<span class="hljs-string">&quot;Are you Ok?&quot;</span>));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈项目管理之团队建设</title>
    <link href="/Management/Make-a-Team/"/>
    <url>/Management/Make-a-Team/</url>
    
    <content type="html"><![CDATA[<h3 id="高效团队的特征"><a href="#高效团队的特征" class="headerlink" title="高效团队的特征"></a>高效团队的特征</h3><p>以任务和结果为导向是高效团队的重要特征.</p><h3 id="团队建设"><a href="#团队建设" class="headerlink" title="团队建设"></a>团队建设</h3><p>布鲁斯·塔克曼的团队发展阶段模型是组织行为学的一种。他提出了塔克曼模型:下图,很好说明了项目团队建设的各个阶段.尽管这些阶段通常按顺序进行,然而,团队停滞在某个阶段或退回到较早阶段的情况也并非罕见.如果团队成员曾经共过事,项目团队建设也可能跳过某个阶段.</p><p><img src="/Management/Make-a-Team/tuckman.png" alt="tuckman"></p><ul><li><strong>形成阶段</strong>:团队成员相互认识,了解了各自的角色和职责,成员之间各自相互独立,不会开诚布公.此时管理人员主要要使用指导的方式来管理项目团队.</li><li><strong>震荡阶段</strong>:成员之间不容易合作,此时不同的观点发生碰撞,如果团队成员不能以合作和开放的态度对待不同的观点和意见,团队环境可能会恶化和破坏.此时管理人员要使用冲突管理(下面展开说明)的方式来管理项目团队.</li><li><strong>规范阶段</strong>:成员开始协同工作,成员行为习惯开始遵从需求,开始互相信任.此时管理人员要采用教练的方式,充分调动团队的积极性.</li><li><strong>成熟阶段</strong>:团队像一个单位有序的工作,成员相互依靠,高效解决问题.此时管理人员要充分授权,让成员充分实现自己的价值.</li><li><strong>解散阶段</strong>:完成工作,团队成员离开项目.此时管理人员应该做好遣散工作.</li></ul><h3 id="冲突管理"><a href="#冲突管理" class="headerlink" title="冲突管理"></a>冲突管理</h3><p>托马斯和基尔曼提出了冲突解决方法的模型:托马斯-基尔曼模型(如下图):</p><p><img src="/Management/Make-a-Team/tumasi.png" alt="tumasi"></p><ul><li><strong>回避</strong>:撤退,一方撤出,躲开,拖延或者推给别人处理</li><li><strong>迁就</strong>:包容或缓解,即求同存异,可以减轻冲突,但是没有长期解决问题,没有达成协议</li><li><strong>妥协</strong>:各方各让一步,达成了协议,但是牺牲了各方的利益.管理者应该以此方法为第二选择方案处理冲突</li><li><strong>竞争</strong>:命令或者强制,他推行一方观念,另一方服从,利用权力强行解决紧急问题,一般不用,也只能临时解决问题.</li><li><strong>合作</strong>:综合考虑各方意见,使各方达成一致,解决问题,管理者应该首选此方法解决冲突.他是面对问题以开放的态度解决问题.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Management</category>
      
    </categories>
    
    
    <tags>
      
      <tag>团队建设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ 实现简单的RPC</title>
    <link href="/RabbitMQ/Make-a-Simple-RPC-by-RabbitMQ/"/>
    <url>/RabbitMQ/Make-a-Simple-RPC-by-RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h3 id="Remote-procedure-call-RPC"><a href="#Remote-procedure-call-RPC" class="headerlink" title="Remote procedure call (RPC)"></a>Remote procedure call (RPC)</h3><p>RPC简单的说就是，远程调用一个函数方法，并得到响应的结果。</p><p>关于RPC方法要注意的点：</p><ol><li>明确什么函数需要写在本地，什么函数需要写在Remote</li><li>编写好响应的文档，明确调用关系</li><li>处理错误情况。什么时候客户端应该重新调用当服务端挂了。</li><li>消费RPC服务时，最好不要阻塞的方式等待结果，最好是异步的。</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li>在本地启动rabbit－server（3.6.1）</li></ol><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/RabbitMQ/Make-a-Simple-RPC-by-RabbitMQ/%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="整体架构.png"></p><p>我们的RPC是这样工作：</p><ol><li>当客户端启动后，他将创建一个匿名的回调队列，用来存放服务的返回结果。</li><li>作为一个RPC请求，这个客户端发送的信息包括两个属性，<strong>replyTo</strong>:它指向回调队列。<br><strong>correlationId</strong>：为每一个请求分配一个唯一的值，以备后面获取服务返回的值使用。</li><li>请求发送到rpc_queue队列上</li><li>RPC worker（Server）监控rpc_queue的这个队列，消费上面的信息，将结果发送到replyTo指定的队列上。</li><li>客户端监控回调队列，通过correlationId取出属于自己的结果。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="maven-GAV"><a href="#maven-GAV" class="headerlink" title="maven GAV"></a>maven GAV</h4><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="客户端（client）"><a href="#客户端（client）" class="headerlink" title="客户端（client）"></a>客户端（client）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java">[RPCClient] []<br><span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.QueueingConsumer;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.AMQP.BasicProperties;<br><span class="hljs-keyword">import</span> java.util.UUID;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RPCClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Connection connection;<br>    <span class="hljs-keyword">private</span> Channel channel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">requestQueueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;rpc_queue&quot;</span>;<br>    <span class="hljs-keyword">private</span> String replyQueueName;<br>    <span class="hljs-keyword">private</span> QueueingConsumer consumer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RPCClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;localhost&quot;</span>);<br>        connection = factory.newConnection();<br>        channel = connection.createChannel();<br>        <span class="hljs-comment">//获取自动命名并且退出就自动销毁的队列,作为回调队列</span><br>        replyQueueName = channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">//在channel使用队列消费</span><br>        consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueueingConsumer</span>(channel);<br>        <span class="hljs-comment">//注册消费这个队列</span><br>        channel.basicConsume(replyQueueName, <span class="hljs-literal">true</span>, consumer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">corrId</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>        <span class="hljs-comment">//设置correlationId和回调队列的名字</span><br>        <span class="hljs-type">BasicProperties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicProperties</span><br>                .Builder()<br>                .correlationId(corrId)<br>                .replyTo(replyQueueName)<br>                .build();<br>        <span class="hljs-comment">//发送消息到rpc请求队列,带上props属性</span><br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, requestQueueName, props, message.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        <span class="hljs-comment">//监控回调队列的结果变化</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            QueueingConsumer.<span class="hljs-type">Delivery</span> <span class="hljs-variable">delivery</span> <span class="hljs-operator">=</span> consumer.nextDelivery();<br>            <span class="hljs-comment">//比较correlationId以确定是否为自己调用的结果</span><br>            <span class="hljs-keyword">if</span> (delivery.getProperties().getCorrelationId().equals(corrId)) &#123;<br>                response = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        connection.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> &#123;<br>        <span class="hljs-type">RPCClient</span> <span class="hljs-variable">fibonacciRpc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fibonacciRpc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RPCClient</span>();<br>            System.out.println(<span class="hljs-string">&quot; [x] Requesting fib(30)&quot;</span>);<br>            <span class="hljs-comment">//执行调用</span><br>            response = fibonacciRpc.call(<span class="hljs-string">&quot;30&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot; [.] Got &#x27;&quot;</span> + response + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span>  (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (fibonacciRpc!= <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fibonacciRpc.close();<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (Exception ignore) &#123;&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="RPC服务端（RPCServer）"><a href="#RPC服务端（RPCServer）" class="headerlink" title="RPC服务端（RPCServer）"></a>RPC服务端（RPCServer）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java">[RPCServer] []<br><span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.QueueingConsumer;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.AMQP.BasicProperties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RPCServer</span> &#123;<br>    <br>    <span class="hljs-comment">//监控的rpc请求队列名字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">RPC_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;rpc_queue&quot;</span>;<br>    <br>    <span class="hljs-comment">//服务</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n ==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>) + fib(n-<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>            factory.setHost(<span class="hljs-string">&quot;localhost&quot;</span>);<br><br>            connection = factory.newConnection();<br>            channel = connection.createChannel();<br><br>            channel.queueDeclare(RPC_QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>            <span class="hljs-comment">//保障在发送确认消息之前,broker不再发送消息过来</span><br>            channel.basicQos(<span class="hljs-number">1</span>);<br>            <span class="hljs-type">QueueingConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueueingConsumer</span>(channel);<br>            channel.basicConsume(RPC_QUEUE_NAME, <span class="hljs-literal">false</span>, consumer);<br>            System.out.println(<span class="hljs-string">&quot; [x] Awaiting RPC requests&quot;</span>);<br>            <span class="hljs-comment">//监控rpc请求消息队列</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">//获取队列消息载体</span><br>                QueueingConsumer.<span class="hljs-type">Delivery</span> <span class="hljs-variable">delivery</span> <span class="hljs-operator">=</span> consumer.nextDelivery();<br>                <span class="hljs-comment">//获取消息带过来的参数</span><br>                <span class="hljs-type">BasicProperties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> delivery.getProperties();<br>                <span class="hljs-comment">//新组织发放回调队列的参数,correlationId以备客户端可以获取属于自己的返回结果</span><br>                <span class="hljs-type">BasicProperties</span> <span class="hljs-variable">replyProps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicProperties</span><br>                        .Builder()<br>                        .correlationId(props.getCorrelationId())<br>                        .build();<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//获取队列消息</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(message);<br><br>                    System.out.println(<span class="hljs-string">&quot; [.] fib(&quot;</span> + message + <span class="hljs-string">&quot;)&quot;</span>);<br>                    <span class="hljs-comment">//调用服务函数</span><br>                    response = <span class="hljs-string">&quot;&quot;</span> + fib(n);<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                    System.out.println(<span class="hljs-string">&quot; [.] &quot;</span> + e.toString());<br>                    response = <span class="hljs-string">&quot;&quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//发送结果信息到客户端的回调队列</span><br>                    channel.basicPublish( <span class="hljs-string">&quot;&quot;</span>, props.getReplyTo(), replyProps, response.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>                    <span class="hljs-comment">//发送确认消息</span><br>                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span>  (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    connection.close();<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (Exception ignore) &#123;&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>如果RPC服务太慢，你可以再启动一个服务端，会自动负载均衡</li><li>客户端只需要发送和接收一个信息，不需要同步调用服务。这样一个RPC服务请求只需要一次网络回路</li></ol><h4 id="遗留问题："><a href="#遗留问题：" class="headerlink" title="遗留问题："></a>遗留问题：</h4><ol><li>如果没有RPC服务在运行，客户端应该怎样重新请求</li><li>客户端是否应该有超时的RPC</li><li>服务端执行过程有一个异常是否应该抛给客户端</li><li>服务端信息校验等保护自己避免攻击的方法</li></ol>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMS协议JMS</title>
    <link href="/Protocol/JMS-Protocol/"/>
    <url>/Protocol/JMS-Protocol/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>JMS 是 Sun Microsystems 公司通过 JSR-914 项目创建的一种企业消息传送 API。JMS 自身 并不是一种消息传送系统;它是消息传送客户端和消息传送系统通信时所需接口和类的一 个抽象。与 JDBC 抽象(JDBC abstract)访问关系数据库、JNDI 抽象访问命名和目录服务 的方式一样,JMS 抽象可以访问消息提供者。使用 JMS,应用程序的消息传送客户端可以 实现跨消息服务器产品的移植</p><h3 id="JMS-API的组成"><a href="#JMS-API的组成" class="headerlink" title="JMS API的组成"></a>JMS API的组成</h3><p>JMS API 可以分为 3 个主要部分:公共 API、点对点 API 和发布&#x2F;订阅 API。在 JMS1.1 中, 公共 API 可被用于向一个队列或一个主题发送消息,或从其中接收消息。点对点 API 专 门用于使用队列的消息传送,而发布&#x2F;订阅 API 则专门用于使用主题的消息传送</p><h4 id="公共API"><a href="#公共API" class="headerlink" title="公共API"></a>公共API</h4><p>在 JMS 公共 API 内部,和发送和接收 JMS 消息有关的 JMS API 接口主要有 7 个:</p><ul><li>ConnectionFactory</li><li>Destination</li><li>Connection</li><li>Session</li><li>Message</li><li>MessageProducer</li><li>MessageConsumer</li></ul><p>在这些公共接口中,ConnectionFactory 和 Destination 必须使用 JNDI(遵照 JMS 规 范要求)从提供者处获得。其他接口则可以通过工厂方法在不同的 API 接口中创建。举例 来说,一旦有了一个 ConnectionFactory,就可以创建一个 Connection。一旦有了一个 Connection,就可以创建一个 Session。而一旦有了一个 Session,就可以创建一个 Message、MessageProducer 和 MessageConsumer。这七个API的关系如图所示：</p><p><img src="/Protocol/JMS-Protocol/%E5%85%AC%E5%85%B1API.png" alt="公共API.png"></p><p>在 JMS 中,是 Session 对象保存着用于消息传送的事务性工作单元(transactional unit), 而不是 Connection 对象。这和 JDBC 不同,JDBC 中是 Connection 对象保存事务性工 作单元。这就意味着在使用 JMS 时,一个应用程序通常只会有一个 Connection 对象,但 是它可以有一个 Session 对象池。</p><h4 id="点对点API"><a href="#点对点API" class="headerlink" title="点对点API"></a>点对点API</h4><p>点对点消息 传送模型 API 特指 JMS API 之内基于队列的接口。下面是用于向一个队列发送和从一个 队列接收消息的接口:</p><ul><li>QueueConnectionFactory</li><li>Queue</li><li>QueueConnection</li><li>QueueSession</li><li>Message</li><li>QueueSender</li><li>QueueReceiver</li></ul><p>下图显示了基于队列的 JMS API 接口之间的流程和关系：</p><p><img src="/Protocol/JMS-Protocol/%E7%82%B9%E5%AF%B9%E7%82%B9API.png" alt="点对点API.png"></p><h4 id="发布-x2F-订阅-API"><a href="#发布-x2F-订阅-API" class="headerlink" title="发布&#x2F;订阅 API"></a>发布&#x2F;订阅 API</h4><p>由于基于主题的 JMS API 类似于基于队列的 API,发布&#x2F;订阅消息传送模型内部使用的接口如下:</p><ul><li>TopicConnectionFactory</li><li>Topic</li><li>TopicConnection</li><li>TopicSession</li><li>Message</li><li>TopicPublisher</li><li>TopicSubscriber<br>请注意:除了 TopicPublisher 和 TopicSubscriber 不同以外,发布&#x2F;订阅域中的接口和 p2p 域中的那些接口名称基本类似。JMS API 在这一点上非常明显。正如本章开始时所述 的那样,发布&#x2F;订阅模型使用主题、发布者和订阅者这些术语,而 p2p 模型使用的则是队 列、发送者和接收者。请注意这些术语是如何和 API 接口名称相匹配的。基于主题的 JMS API 接口的关系和流程如下图所示：</li></ul><p><img src="/Protocol/JMS-Protocol/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%BC%8FAPI.png" alt="发布订阅式API.png"></p><h3 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h3><h4 id="面向服务体系结构（Service-Oriented-Architecture）"><a href="#面向服务体系结构（Service-Oriented-Architecture）" class="headerlink" title="面向服务体系结构（Service-Oriented Architecture）"></a>面向服务体系结构（Service-Oriented Architecture）</h4><p>面向服务体系结构(Service-Oriented Architecture,SOA)作为一种体系结构体系,定义了 从对应的企业服务实现中抽象出来的业务服务。因此,SOA 已经促生了一种称为企业服 务总线(ESB)的新类型中间件。在 SOA 发展的早期阶段,大多数 ESB 是作为消息代理 实现的,由此,消息传送层内部的组件会用于执行某种智能路由选择,或者用于在传送消 息之前进行消息转换。这些早期的消息代理,已经发展成为成熟的商业 ESB 产品和开源 ESB 产品,它们在核心之处使用了消息传送机制。尽管某些 ESB 产品能够支持传统的非 JMS 型 HTTP 传送,但是,大多数企业级产品的实现仍然采用消息传送作为通信协议。</p><p>在需要将业务服务从其底层实现中完全抽象出来的 SOA 内部构建抽象层时,消息传送是 一种极好的手段。使用消息传送机制,业务服务无须关心对应的实现服务位于何处、使用 哪种语言编程、在哪种平台上部署,甚至不需要关心实现服务的名称。消息传送机制还提 供了在 SOA 环境内部所需的可伸缩性,另外,它还对进、出 ESB 的请求提供了一种健壮 的监控手段。现在,几乎所有可用的商业 ESB 产品和开源 ESB 产品都支持 JMS 消息传送 作为一种通信协议——最值得注意的例外就是 Microsoft 公司的消息传送产品系列(例如, BizTalk 和 MSMQ)。</p><p>业内对于 SOA 的热衷和应用,反过来又掀起了普遍使用消息传送解决方案的热潮。尽管 完全成熟的 SOA 实现尚在不断发展之中,许多公司就已经开始转向消息传送解决方案, 将其作为迈向 SOA 的其中一步。</p><h4 id="事件驱动体系结构-（Event-Driven-Architecture）"><a href="#事件驱动体系结构-（Event-Driven-Architecture）" class="headerlink" title="事件驱动体系结构 （Event-Driven Architecture）"></a>事件驱动体系结构 （Event-Driven Architecture）</h4><p>事件驱动体系结构(EDA)作为一种体系结构体系,它建立在下列前提之上:进程和事件 编排是动态的和非常复杂的,因而通过一个中央编排组件来控制或实现是不可行的。当系 统中发生了一个活动时,该进程将向整个系统发送一个事件,以此指示发生了一个活动(一 个事件)。这个事件接下来可能会启动(kick off)其他进程,这些进程又可以依次启动附 加的进程,所有进程都会相互去耦。</p><p>在 EDA 的一些优秀范例中,包括了保险领域和养老金固定收益领域。这些行业领域都是 由发生在该系统中的事件来驱动的。像修改您的地址这样一些简单的事情,也会影响到保 险领域的许多方面,其中包括政策、报价及消费者记录等。在这个例子中,保险应用程序 中的驱动事件就是修改地址。然而,修改地址模块并无责任去知道该事件所导致的一切后 果。因此,该修改地址模块仅仅发送一条事件消息,让系统知道修改了某个地址。报价系 统将获知这个事件,并对提供给该消费者的所有未执行报价进行调整。同时,政策系统将 获知这个地址修改事件,并调整该消费者的费率和适用政策。</p><p>EDA 的另一个例子是在养老金固定收益领域。结婚或变换工作会触发系统中的某个事件, 它使您有资格对自己的健康和退休金信息进行某些修改。许多系统会使用 EDA,以此来 避免使用一个庞大、复杂而且难以维护的中央处理引擎来控制与特定的“合格事件”有关 的所有活动。</p><p>消息传送机制是基于事件驱动体系结构系统的基础。通常来说,事件一般是以空负载 (empty payload)消息的模式来实现的,这些消息会在消息头中包含和事件有关的一些信 息,尽管某些消息会将应用程序数据作为事件的一部分进行传送。毫不足奇的是,基于 EDA 的体系结构大多使用发布&#x2F;订阅模型,作为在系统内部广播事件的手段。</p><h4 id="异构平台集成-（Heterogeneous-Platform-Integration）"><a href="#异构平台集成-（Heterogeneous-Platform-Integration）" class="headerlink" title="异构平台集成 （Heterogeneous Platform Integration）"></a>异构平台集成 （Heterogeneous Platform Integration）</h4><p>多数公司,经由合并、收购、移植或错误决策的诸多因素组合,最终会拥有种类繁多的 异构业务支撑平台、产品和语言。显然,集成这些平台是一项挑战性极强的任务,特别是 相关标准也在持续不断地发展和演变之中。消息传送机制在这些异构平台相互通信之中起 到了关键作用,无论这些平台是 Java EE 或 Microsoft .NET、Java EE 和 CICS,还是 Java EE 和 Tuxedo C++等。</p><p>尽管像 Java 这样的平台可以使用 JMS API,而其他平台,比如.NET 或 C++却都无法使用 (其原因显而易见)。许多商业消息传送系统厂商和开源消息传送系统厂商都会支持 JMS API 和一个本机 API。这些提供者一般都有一个内置的消息传送桥,它允许提供者将一条<br>JMS 消息转换为内部消息,反之亦然。某些平台,比如说.NET,可能会需要一个外部消 息传送桥,将一条 JMS 消息转换为 MSMQ 消息(这取决于您所使用的消息提供者)。例 如,ActiveMQ 就提供了一个消息传送桥,用于将 MSMQ 消息转换为 JMS 格式(反之亦 然)。这种低级的平台集成已经引发了范围更广的集成热潮,比如著名的企业应用集成 (Enterprise Application Integration)等。</p><h4 id="企业应用集成（Enterprise-Application-Integration）"><a href="#企业应用集成（Enterprise-Application-Integration）" class="headerlink" title="企业应用集成（Enterprise Application Integration）"></a>企业应用集成（Enterprise Application Integration）</h4><p>大多数成熟的组织都同时拥有遗留(legacy)应用系统和新的应用系统,这些系统都是独 立实现的,而且无法实现互操作。很多时候,各个组织都会有将这些应用系统集成起来的 强烈需求,以便它们能够在大规模企业运行中共享信息并实现协作。这些应用系统的集成 通常称为企业应用集成(Enterprise Application Integration,EAI)。</p><p>虽然 EAI 使用了大量的厂商提供的和自己开发的解决方案,但是,企业消息传送系统仍然 是大多数解决方案的主流。企业消息传送系统允许烟囱式(stovepipe)应用系统(由异构 产品、技术与组件等组成)和事件进行通信并交换数据,同时还保持物理上的独立。数据 和事件可以通过主题或队列以消息的形式进行交换,它们提供了可以实现各个参与应用系 统去耦的一个抽象。</p><p>举例来说,一个消息传送系统可能会被用于实现一个因特网订单处理系统和像 SAP 这样 的企业资源规划(Enterprise Resource Planning,ERP)系统的集成。该因特网系统使用 JMS 向一个主题传送有关新订单的业务数据。而一个 ERP 网关应用程序,它通过本机 API 访 问一个 SAP 应用程序,能够订阅该订单主题。当新订单广播到该主题时,网关就会接收 到这个订单,并将它们纳入 SAP 应用程序的处理之中。</p><h4 id="企业到企业（Business-to-Business）"><a href="#企业到企业（Business-to-Business）" class="headerlink" title="企业到企业（Business-to-Business）"></a>企业到企业（Business-to-Business）</h4><p>历史上,企业曾使用电子数据交换(Electronic Data Interchange,EDI)系统来交换数据。 数据严格使用固定的格式,通过专用增值网络(Value-Added Network,VAN)来实现交换。 这种接入的成本很高,而且数据通常是以批处理的方式,而不是以实时业务事件的方式来 进行交换的。</p><p>因特网、XML 和现代消息传送系统已经从根本上改变了在如今称为企业到企业 (Business-to-Business,B2B)的系统中,如何进行业务数据交换和交互的状况。使用消 息传送系统是现代 B2B 解决方案的主流趋势,因为它允许各个组织相互协作,而无须将 它们的业务系统紧密集成起来。此外,它还降低了接入门槛,因为细粒度(finer-grained) 的参与已经成为可能。根据和企业相结合的队列和主题的不同,它们既可以加入到 B2B 之中,也可以自由退出。<br>举个例子,一个制造商能够建立一个关于原料招标广播请求的主题。各家供应商都可以订 阅该主题,并通过向该制造商队列生产消息而实现响应。制造商可以根据意愿添加和删除 供应商,而且,关于各类存货和原料的新主题和队列,也可以用以正确区分各个系统。</p><h4 id="地理分散（Geographic-Dispersion）"><a href="#地理分散（Geographic-Dispersion）" class="headerlink" title="地理分散（Geographic Dispersion）"></a>地理分散（Geographic Dispersion）</h4><p>如今,很多公司在地理上都是分散的。所有的砖墙加灰泥式的(brick-and-mortar)传统实 体公司、鼠标加灰泥式的(click-and-mortar)新型公司及时兴的网络化(dot-coms)公司 都面临着和企业系统地理分散有关的诸多问题。比如,远程仓库中的存货系统需要和位于 公司总部的集中式内部 ERP 系统进行通信;由各个子公司本地管理的敏感雇员数据需要 和总公司实现同步等。JMS 消息传送系统能够确保地理上分散的业务数据交换的安全性和 可靠性。</p><h4 id="信息广播-（Information-Broadcasting）"><a href="#信息广播-（Information-Broadcasting）" class="headerlink" title="信息广播 （Information Broadcasting）"></a>信息广播 （Information Broadcasting）</h4><p>拍卖网站、股票报价服务和证券交易,所有这些应用都必须将数据以一对多的方式推送给 堪称海量的接收者。在许多情况下,广播信息都需要各个接收者逐一选择路由和过滤。当 输出信息要以一对多的方式进行传送时,经常要将对这种信息的响应发回给广播者。这是 企业消息传送非常适用的另一种情况,因为发布&#x2F;订阅模型可以用于发布消息,而 p2p 模 型则可以用于响应。</p><p>在这些情况下,传送可靠性的选择成了关键因素。举例来说,在广播股票报价时绝对地保 证信息传送,这可能并不是最重要的,因为同一股票代码很可能会在较短的时间间隔内进 行另一次广播。然而,在交易者通过购买订单对报价做出响应的情况下,以保证的 (guaranteed)方式返回响应是至关重要的。此时,您需要综合利用消息传送机制的可靠 性,因为发布&#x2F;订阅模型分发速度很快但并不可靠,而使用 p2p 模型从交易者处购买订单 则是非常可靠的。JMS 和企业消息传送为发布&#x2F;订阅和 p2p 这两种模型都提供了不同程度 的可靠性。</p><h4 id="构建动态系统（Building-Dynamic-Systems）"><a href="#构建动态系统（Building-Dynamic-Systems）" class="headerlink" title="构建动态系统（Building Dynamic Systems）"></a>构建动态系统（Building Dynamic Systems）</h4><p>在 JMS 中,发布&#x2F;订阅主题和 p2p 队列是集中管理的,并都称为 JMS 受管对象。您的应用 程序和另一个应用程序通信时,并不用知道各个主题或队列的网络位置;它仅仅将主题和 队列对象作为标识符使用而已。使用主题和队列为 JMS 应用程序提供了一定程度的位置 透明性和灵活性,这使得在一个企业系统中添加和删除参与者成为可能。</p><p>举例来说,一个系统管理员能够在按需添加的基础上,动态地向特定主题添加订阅者。一 个常见的场景可能会是:您是否发现需要为特定的消息而不是其他消息添加一个审计跟踪 (audit-trail)机制。下图显示了您如何只通过订阅您所感兴趣的主题,来插入一个专用 的审计和日志记录 JMS 客户端。这个客户端唯一的工作就是跟踪特定的消息。</p><p><img src="/Protocol/JMS-Protocol/%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F.png" alt="动态系统.png"></p><p>企业系统有了添加和删除生产者、消费者的能力,就可以在一个已经部署好的环境中,动态改变消息路由并重新选择路由。</p><p>在上图中,其他 JMS 应用程序(A 和 B)还订阅了采购订单主题,并独立进行处理。应 用程序 A 可能是公司内的一个遗留应用程序,而应用程序 B 则可能是另一家公司的业务 系统,以此来表示 B2B 集成。</p><p>我们也可以在前面讨论的 EAI 场景上来构建另外一个例子。在这个例子中,一个网关接收 输入的采购订单,将它们转换为适用于遗留 ERP 系统的格式,并调入 ERP 系统进行处理 (参见下图)。</p><p><img src="/Protocol/JMS-Protocol/%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F2.png" alt="动态系统2.png"></p><p>使用 JMS 从这个流程中添加和删除应用程序,这是非常容易的。例如,如果需要处理来 源不同的采购订单,比如一个来自基于因特网的系统,而另一个则来自遗留的 EDI 系统, 只需要将遗留采购订单系统加入混合系统之中即可(参见下图)</p><p><img src="/Protocol/JMS-Protocol/%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F3.png" alt="动态系统3.png"></p><p>这个例子有意思之处就在于,ERP 网关并未意识到,它是从两个完全不同的来源接收到采 购订单消息。遗留 EDI 系统可以是一个比较旧的内部系统,或者是一个业务伙伴或新近并 购的一家子公司的主系统。此外,还可以动态地将遗留 EDI 系统添加进去,而不需要关机 和重组整个系统。企业消息传送系统使得这种灵活性成为可能,同时,JMS 还允许 Java 客户端使用相同的 Java 编程模型来访问多个不同的消息传送系统。</p><h3 id="RPC-和异步消息传送（RPC-Versus-Asynchronous-Messaging）"><a href="#RPC-和异步消息传送（RPC-Versus-Asynchronous-Messaging）" class="headerlink" title="RPC 和异步消息传送（RPC Versus Asynchronous Messaging）"></a>RPC 和异步消息传送（RPC Versus Asynchronous Messaging）</h3><p>RPC(Remote Procedure Call,远程过程调用)是通常用于描述分布式计算模型的术语, 现在 Java 和.NET 这两种平台都在使用这个术语。基于组件的体系结构,比如企业级 JavaBean(Enterprise JavaBeans,EJB),就是建立在这个模型基础之上的。对于许多应用程 序来说,基于 RPC 的技术已经是,并且将继续是切实可行的解决方案。不过,企业消息 传送模型在特定类型的分布式应用程序中表现更为出色。</p><h4 id="紧密耦合的-RPC-（Tightly-Coupled-RPC）"><a href="#紧密耦合的-RPC-（Tightly-Coupled-RPC）" class="headerlink" title="紧密耦合的 RPC （Tightly Coupled RPC）"></a>紧密耦合的 RPC （Tightly Coupled RPC）</h4><p>紧密耦合的 RPC 模型最为成功的一个领域就是构建 3 层或 n 层应用程序。在这个模型中, 表示层(第 1 层)使用 RPC 和中间层(第 2 层)的业务逻辑进行通信,访问位于后端(第 3 层)的数据。Sun Microsystems 公司的 J2EE 平台和 Microsoft 公司的.NET 平台是这种体 系结构最为先进的范例。</p><p>使用 J2EE、JSP 和 servlet 描述的是表示层,而企业级 JavaBean(EJB)则是中间层。抛开 平台不论,这些系统使用的核心技术是基于成为定义通信范例的 RPC 的中间件。</p><p>RPC 试图模仿在一个进程中运行的某个系统的行为。在调用一个远程过程时,调用者将被 阻塞,直到该过程完成并将控制权返回给调用者。从开发者的角度看,这种同步模型使得 该系统就好像运行在一个进程当中。这些工作会依次完成,同时确保以预定顺序完成。RPC 同步的本质特性,将客户端(进行调用的软件)和服务器(为该调用服务的软件)二者紧 密耦合在一起。因为客户端已被阻塞,所以它无法继续进行工作,直到服务器做出响应为 止。</p><p>RPC 紧密耦合的本质特性导致出现了相互高度依赖的系统,其中一个系统的失效会对其他 系统产生立竿见影的弱化影响。例如,在 J2EE 中,如果期望使用企业级 bean 的 servlet 顺利工作,EJB 服务器就必须正常地发挥功能。<br>虽然 RPC 在许多场景中表现优秀,但是在系统对系统(system-to-system)的处理过程当 中,它的同步、紧密耦合等本质特性却是一个严重的缺陷,因为“系统对系统”有很多垂 直的应用程序集成在一起。在系统对系统场景中,垂直系统之间的通信线路不仅数量众多, 而且方向也是错综复杂的,如下图所示</p><p><img src="/Protocol/JMS-Protocol/RPC%E7%B3%BB%E7%BB%9F.png" alt="RPC系统.png"></p><p>让我们设想一下使用紧密耦合的 RPC 机制实现这种基础设施所面临的挑战。这些系统之 间的连接管理是多对多(many-to-many)的问题。当您向混合系统中加入另一个应用程序 时,您不得不回过头来让其余所有的系统都知道它,而且,这些系统也会崩溃(crash)。 它们仍然需要预定停工时间(scheduled downtime),而且对象的接口也需要升级。<br>当该系统的一部分中断运行时,一切都得停止。当您向一个订单输入系统添加订单时,它 要对其他系统逐个进行同步调用。这会导致订单输入系统发生阻塞,并一直等待,直到每 个系统都处理完该订单时为止。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="像 CORBA 单向调用这种多线程的、松散的 RPC 机制也是一种选择,不过,这些解决方 案自身非常复杂,而且它们还需要成熟完善的开发。当没有“明智地”使用线程时,它 们的开销很大,而且在出现故障的情况下,CORBA 单向调用仍然需要进行应用程序级 (application-level)错误处理。">[1]</span></a></sup></p><p>正是 RPC 系统的同步、紧密耦合、相互依赖等本质特性,使得子系统中出现的故障最终 会导致整个系统的失效。就像在“系统对系统”场景中那样,当 RPC 紧密耦合的本质特 性不再适用时,消息传送机制为此提供了另一种选择方案。</p><h4 id="企业消息传送-Enterprise-Messaging"><a href="#企业消息传送-Enterprise-Messaging" class="headerlink" title="企业消息传送 (Enterprise Messaging)"></a>企业消息传送 (Enterprise Messaging)</h4><p>各个子系统在可用性方面存在的问题,并不是使用面向消息的中间件所带来的后果。消息 传送机制的一个基本思想就是:规定应用程序之间的通信应该采用异步方式。将各部分连 接在一起的代码会假定这是一条单向消息,它不需要立即从另一个应用程序那里得到响 应。换句话说,也就是没有出现阻塞现象。一旦一条消息被发出,消息传送客户端就能够 转向其他任务;它不必等待对这条消息的响应。这是 RPC 和异步消息传送之间的主要区 别,而且,它对于理解消息传送系统的优点来说至关重要。</p><p>在一个异步消息传送系统当中,每个子系统(收款、存货等)都不存在和其他系统的耦合 (参见下图)。它们通过消息传送服务器进行通信,因此,某个子系统出现故障,并不 会妨碍其他子系统的运行。</p><p><img src="/Protocol/JMS-Protocol/%E4%BC%81%E4%B8%9A%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%81.png" alt="企业消息传送.png"></p><p>在网络化系统中会出现局部故障,这是一个不可避免的事实。其中的一个系统,可能会在 其连续运行期间的某个时刻,发生不可预测的故障,或者需要停机。这种现象可能会由于 内部系统和合作系统地理上的分散而被进一步放大。考虑到这个因素,JMS 提供了保证传 送(guaranteed delivery)方式,它可以确保即便发生了局部故障,预定消费者最终也会接 收到这条消息。</p><p>保证传送使用的是一种“保存并转发(store-and-forward)”的机制,这就意味着,如果预 定消费者当前并不可用,底层消息服务器就会将输入的消息写到一个持久存储器 (persistent store)之中。随后,当该接收应用程序变为可用时,“保存并转发”机制会把 预定消费者在不可用时错过的所有消息传送给它们(参见下图)。</p><p><img src="/Protocol/JMS-Protocol/%E4%BF%9D%E5%AD%98%E5%B9%B6%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6.png" alt="保存并转发机制.png"></p><p>概括来说,JMS 不仅仅是另外一种事件服务。它的设计涵盖了范围极广的企业应用程序, 包括 EAI、B2B 和推送模型等。通过异步处理、“保存并转发”及“保证传送”机制,它 为保持业务应用程序连续运行并实现不间断服务提供了很高的可用性。它还通过发布&#x2F;订 阅功能和点对点功能,提供了集成灵活性。通过位置透明和管理控制,它提供了一种健壮 的、基于服务的体系结构。而且,最重要的是,它非常易于学习和使用。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>像 CORBA 单向调用这种多线程的、松散的 RPC 机制也是一种选择,不过,这些解决方 案自身非常复杂,而且它们还需要成熟完善的开发。当没有“明智地”使用线程时,它 们的开销很大,而且在出现故障的情况下,CORBA 单向调用仍然需要进行应用程序级 (application-level)错误处理。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Protocol</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JMS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA类初始化</title>
    <link href="/Java/Java-Class-init/"/>
    <url>/Java/Java-Class-init/</url>
    
    <content type="html"><![CDATA[<h3 id="JAVA类初始化"><a href="#JAVA类初始化" class="headerlink" title="JAVA类初始化"></a>JAVA类初始化</h3><ol><li>静态块只会调用一次</li><li>可以触发静态块的有:调用类静态非final属性;Class.forName方法;new关键字</li><li>非静态代码块,每次调用new关键字的时候都会调用</li><li>调用类字面量时和编译器常量时,不会触发静态代码块和非静态代码块</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><pre><code class="hljs java">[]<span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Initable</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticFinal</span> <span class="hljs-operator">=</span> <span class="hljs-number">47</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticFinal2</span> <span class="hljs-operator">=</span> ClassInitialization.rand.nextInt(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Initializing Initable&quot;</span>);<br>    &#125;<br><br>    &#123;<br>      System.out.println(<span class="hljs-string">&quot;non static block initializing!!!!&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Initable2</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticNonFinal</span> <span class="hljs-operator">=</span> <span class="hljs-number">147</span>;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Initializing Initable2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Initable3</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticNonFinal</span> <span class="hljs-operator">=</span> <span class="hljs-number">74</span>;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Initializing Initable3&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassInitialization</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]arvg)</span>&#123;<br>      <span class="hljs-comment">//调用类字面量不会调用static块,也不会调用非static块</span><br>      <span class="hljs-comment">// Class initable = Initable.class;</span><br>      <span class="hljs-comment">// System.out.println(&quot;11111111111111111111111111&quot;);</span><br>      <span class="hljs-comment">// //调用类的编译期常量也不会调用类的static块,也不会调用非static块</span><br>      <span class="hljs-comment">// System.out.println(Initable.staticFinal);</span><br>      <span class="hljs-comment">// System.out.println(&quot;22222222222222222222222222&quot;);</span><br>      <span class="hljs-comment">// //编译期的常量并非只要static和final修饰就是,但是这是必要的条件,静态量的调用不会调用非static块</span><br>      <span class="hljs-comment">// System.out.println(Initable.staticFinal2);</span><br>      System.out.println(<span class="hljs-string">&quot;33333333333333333333333333&quot;</span>);<br>      <span class="hljs-comment">//每次使用new方法会都调用非static块和第一次调用的静态块</span><br>      <span class="hljs-type">Initable</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Initable</span>();<br>      System.out.println(Initable.staticFinal2);<br>      System.out.println(<span class="hljs-string">&quot;44444444444444444444444444&quot;</span>);<br>      <span class="hljs-type">Initable</span> <span class="hljs-variable">demo1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Initable</span>();<br>      System.out.println(<span class="hljs-string">&quot;555555555555555555555555555555&quot;</span>);<br>      <span class="hljs-comment">//调用静态非final属性会调用static块</span><br>      System.out.println(Initable2.staticNonFinal);<br>      System.out.println(<span class="hljs-string">&quot;6666666666666666666666666666666&quot;</span>);<br>      <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">//使用Class.forName会调用static块</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">initable3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;Initable3&quot;</span>);<br>      &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;&#125;<br><br>        System.out.println(<span class="hljs-string">&quot;77777777777777777777777777777777&quot;</span>);<br>      <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">initable4</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;Initable3&quot;</span>);<br>      &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;&#125;<br>      System.out.println(<span class="hljs-string">&quot;88888888888888888888888888888888888&quot;</span>);<br>      System.out.println(Initable3.staticNonFinal);<br><br><span class="hljs-comment">//       33333333333333333333333333</span><br><span class="hljs-comment">// Initializing Initable</span><br><span class="hljs-comment">// non static block initializing!!!!</span><br><span class="hljs-comment">// 836</span><br><span class="hljs-comment">// 44444444444444444444444444</span><br><span class="hljs-comment">// non static block initializing!!!!</span><br><span class="hljs-comment">// 555555555555555555555555555555</span><br><span class="hljs-comment">// Initializing Initable2</span><br><span class="hljs-comment">// 147</span><br><span class="hljs-comment">// 6666666666666666666666666666666</span><br><span class="hljs-comment">// Initializing Initable3</span><br><span class="hljs-comment">// 77777777777777777777777777777777</span><br><span class="hljs-comment">// 88888888888888888888888888888888888</span><br><span class="hljs-comment">// 74</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Class</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Etcd简介</title>
    <link href="/Docker/Etcd/"/>
    <url>/Docker/Etcd/</url>
    
    <content type="html"><![CDATA[<h3 id="etcd的特点："><a href="#etcd的特点：" class="headerlink" title="etcd的特点："></a>etcd的特点：</h3><ul><li><strong>简单</strong>:基于HTTP＋JSON的API，用curl命令就可以轻松使用</li><li><strong>安全</strong>:可选的SSL客户认证机制</li><li><strong>快速</strong>:每个实例每秒支持一千次写操作</li><li><strong>可信</strong>:使用Raft算法充分实现了分布式</li></ul><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><h5 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h5><figure class="highlight markdown"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs markdown">从本质上讲，服务发现就是想要了解集群中是否有进程在监听<span class="hljs-emphasis">_UDP_</span>和<span class="hljs-emphasis">_TCP_</span>端口，并且通过对应的字符串（名字）信息就可以进行查找和链接。要解决这些问题需要以下三大支柱，缺一不可：<br><span class="hljs-bullet">1.</span> 一个强一致性，高可用的服务存储目录 基于Raft算法的etcd天生就是这样一个强一致性，高可用的服务存储目录<br><span class="hljs-bullet"> 2.</span> 一种注册服务和监控服务健康状态的机制 用户可以在etcd中注册服务，并且对注册服务设置<span class="hljs-emphasis">_key TTL_</span>,定时保持服务的心跳以达到监控健康状态的效果<br><span class="hljs-bullet"> 3.</span> 一种查找和链接服务的机制 通过在etcd指定的主题下注册的服务也能在对应的主题下被查找到。为了确保连接，可以在每个服务机器上都部署一个Proxy模式的etcd，这样就可以确保能访问etcd集群的服务都能互相连接。<br></code></pre></td></tr></table></figure><h5 id="消息发布与订阅"><a href="#消息发布与订阅" class="headerlink" title="消息发布与订阅"></a>消息发布与订阅</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">在分布式系统中最适合组件间通信的方式就是消息发布与订阅机制<br></code></pre></td></tr></table></figure><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这里所说的指的是软负载均衡。在分布式系统中，为了保证服务的高可用以及数据的一致性，通常会部署多份数据和服务。以达到对等服务，即使其中一个服务失效了，也不影响使用。这样虽然会在一定程度上导致数据写入性能下降，但却能实现数据访问的负载均衡。<br></code></pre></td></tr></table></figure><h5 id="分布式通知与协调"><a href="#分布式通知与协调" class="headerlink" title="分布式通知与协调"></a>分布式通知与协调</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这里讨论的分布式通知与协调，与消息发布与订阅有些相似。两者都使用了etc中的Watcher机制,通过注册和异步通知机制，实现了分布式环境下不同系统之间的通知与协调，从而对数据变化进行实时处理。具体实现方法通常为：不同系统都在etc上对同一目录进行注册，同时设置Watcher监控该目录的变化。当某个系统更新了etcd的目录，那么设置了Watcher的系统就会收到通知，并做出相应的处理。<br></code></pre></td></tr></table></figure><ul><li>通过etcd进行低耦合的心跳检测 检测系统和被检测系统通过etcd上某个目录关联起来而不是直接关联，这样就大大降低了耦合</li><li>通过etcd完成系统调度 某系统由控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台做的一些操作，实际上只需要修改etcd上某些目录节点的状态，etcd就会自动把这些变化通知给注册了Watcher的推送系统客户端，推送系统再作出相应的推送服务。</li><li>通过etcd完成工作汇报 大部分类似的任务分发系统会在子任务启动后，到etcd来注册一个临时目录，并且定时将自己的进度进行汇报（即将进度写入到这个临时目录），这样任务管理者就能实时知道任务进度</li></ul><h5 id="分布式锁与竞选"><a href="#分布式锁与竞选" class="headerlink" title="分布式锁与竞选"></a>分布式锁与竞选</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，因此很容易实现分布式锁。<br></code></pre></td></tr></table></figure><p><em>锁服务有两种方式</em></p><ul><li><p><code>保持独占</code></p><p>所有试图获得锁的用户最终只有一个可以得到。etcd为此提供了一套实现分布式锁原子操作CAS（CompareAndSwap）的API。通过设置preExist值，可以保证在多个节点同时创建某个目录时，只有一个成功，而该用户即可认为获得了锁</p></li><li><p><code>控制时序</code></p><p>所有试图获得锁的用户都会进入等待队列，获得锁的顺序是全局唯一的，同时决定了队列的执行顺序。etcd也为此提供了一套API（自动创建有序健），对一个目录建值时指定为POST动作，这样etcd会自动在目录下生成一个当前最大的值为健，存储这个新的值（客户端编号），同时还可以使用API按顺序列出所有当前目录下的键值。此时这些健的值就是客户端的时序，而这些健中存储的值可以是代表客户端的编号。</p><p>另外，使用分布式锁可以完成Leader竞选。对于一些长时间的CPU计算或者使用I／O操作，只需要由竞选出的Leader计算或者处理一次，再把结果复制给其他Follwer即可，从而避免重复劳动，节约计算资源。</p></li></ul><h5 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h5><p>分布式队列的常规用法与控制时序的分布式锁用法类似，即创建一个先进先出的队列，保证顺序。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">另一种比较有意思的实现是在保证队列达到某个条件时再统一按顺序执行。这种方法的实现可以在／queue这个目录下另外建立一个／queue／<span class="hljs-keyword">condition</span>的节点。<br><span class="hljs-keyword">condition</span>可以表示队列大小。例如，一个大的任务需要在很多小任务就绪情况下才能执行，每次有一个小任务就绪，就给<span class="hljs-keyword">condition</span>数字加<span class="hljs-number">1</span>，直到达到大任务规定的数字，再开始执行队列里的一系列小任务，最终执行大任务。<br><span class="hljs-keyword">condition</span>可以表示某个任务是否在队列。这个任务可以是所有排序任务的首个执行程序，也可以是拓扑结构中没有依赖的点。通常，必须执行这些任务后才能执行队列中的其它任务。<br><span class="hljs-keyword">condition</span>还可以表示其它的一类开始执行任务的通知。可以控制程序指定，当<span class="hljs-keyword">condition</span>出现变化时，开始执行队列任务。<br></code></pre></td></tr></table></figure><h5 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h5><p>通过etcd来进行监控，实现起来非常简单并且实时性强，主要用到了以下两点特性：</p><ul><li>Watcher机制，当某个节点消失或有变动时，Watcher并第一时间发现并告知用户。</li><li>节点可以设置TTL key，例如：每隔30秒向etcd发送一次心跳，代表节点仍然存活；否则说明节点消失。</li></ul><hr><h4 id="Zookeeper应用场景一览"><a href="#Zookeeper应用场景一览" class="headerlink" title="Zookeeper应用场景一览"></a>Zookeeper应用场景一览</h4><h5 id="数据发布与订阅（配置中心）"><a href="#数据发布与订阅（配置中心）" class="headerlink" title="数据发布与订阅（配置中心）"></a>数据发布与订阅（配置中心）</h5><p>发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。</p><ul><li><p>应用中用到的一些配置信息放到ZK上进行集中管理。这类场景通常是这样：应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。</p></li><li><p>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在ZK的一些指定节点，供各个客户端订阅使用。</p></li><li><p>分布式日志收集系统。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用来分配收集任务单元，因此需要在ZK上创建一个以应用名作为path的节点P，并将这个应用的所有机器ip，以子节点的形式注册到节点P上，这样一来就能够实现机器变动的时候，能够实时通知到收集器调整任务分配。</p></li><li><p>系统中有些信息需要动态获取，并且还会存在人工手动去修改这个信息的发问。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入ZK之后，就不用自己实现一套方案了，只要将这些信息存放到指定的ZK节点上即可。</p><p><strong>注意：在上面提到的应用场景中，有个默认前提是：数据量很小，但是数据更新可能会比较快的场景。</strong></p></li></ul><h5 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>这里说的负载均衡是指软负载均衡。在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。</p><p>消息中间件中发布者和订阅者的负载均衡，linkedin开源的KafkaMQ和阿里开源的metaq都是通过zookeeper来做到生产者、消费者的负载均衡。这里以metaq为例如讲下：</p><p><strong>生产者负载均衡：</strong></p><p>metaq发送消息的时候，生产者在发送消息的时候必须选择一台broker上的一个分区来发送消息，因此metaq在运行过程中，会把所有broker和对应的分区信息全部注册到ZK指定节点上，默认的策略是一个依次轮询的过程，生产者在通过ZK获取分区列表之后，会按照brokerId和partition的顺序排列组织成一个有序的分区列表，发送的时候按照从头到尾循环往复的方式选择一个分区来发送消息。</p><p><strong>消费负载均衡：</strong></p><p>在消费过程中，一个消费者会消费一个或多个分区中的消息，但是一个分区只会由一个消费者来消费。MetaQ的消费策略是：</p><ul><li>每个分区针对同一个group只挂载一个消费者。</li><li>如果同一个group的消费者数目大于分区数目，则多出来的消费者将不参与消费。</li><li>如果同一个group的消费者数目小于分区数目，则有部分消费者需要额外承担消费任务。<br><strong>在某个消费者故障或者重启等情况下，其他消费者会感知到这一变化（通过 zookeeper watch消费者列表），然后重新进行负载均衡，保证所有的分区都有消费者进行消费。</strong></li></ul><h5 id="命名服务-Naming-Service"><a href="#命名服务-Naming-Service" class="headerlink" title="命名服务(Naming Service)"></a>命名服务(Naming Service)</h5><p>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。</p><p>阿里巴巴集团开源的分布式服务框架Dubbo中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表，点击这里查看Dubbo开源项目。在Dubbo实现中：</p><p><strong>服务提供者在启动的时候</strong>，向ZK上的指定节点&#x2F;dubbo&#x2F;${serviceName}&#x2F;providers目录下写入自己的URL地址，这个操作就完成了服务的发布。</p><p><strong>服务消费者启动的时候</strong>，订阅&#x2F;dubbo&#x2F;${serviceName}&#x2F;providers目录下的提供者URL地址， 并向&#x2F;dubbo&#x2F;${serviceName} &#x2F;consumers目录下写入自己的URL地址。</p><p>*<strong>注意，所有向ZK上注册的地址都是临时节点，这样就能够保证服务提供者和消费者能够自动感应资源的变化。<br>另外，Dubbo还有针对服务粒度的监控，方法是订阅&#x2F;dubbo&#x2F;${serviceName}目录下所有提供者和消费者的信息。*</strong></p><h5 id="分布式通知-x2F-协调"><a href="#分布式通知-x2F-协调" class="headerlink" title="分布式通知&#x2F;协调"></a>分布式通知&#x2F;协调</h5><p>ZooKeeper中特有watcher注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理。使用方法通常是不同系统都对ZK上同一个znode进行注册，监听znode的变化（包括znode本身内容及子节点的），其中一个系统update了znode，那么另一个系统能够收到通知，并作出相应处理</p><ul><li>另一种心跳检测机制：检测系统和被检测系统之间并不直接关联起来，而是通过zk上某个节点关联，大大减少系统耦合。</li><li>另一种系统调度模式：某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了ZK上某些节点的状态，而ZK就把这些变化通知给他们注册Watcher的客户端，即推送系统，于是，作出相应的推送任务。</li><li>另一种工作汇报模式：一些类似于任务分发系统，子任务启动后，到zk来注册一个临时节点，并且定时将自己的进度进行汇报（将进度写回这个临时节点），这样任务管理者就能够实时知道任务进度。</li></ul><p>*<strong>总之，使用zookeeper来进行分布式通知和协调能够大大降低系统之间的耦合*</strong></p><h5 id="集群管理与Master选举"><a href="#集群管理与Master选举" class="headerlink" title="集群管理与Master选举"></a>集群管理与Master选举</h5><ul><li>集群机器监控：这通常用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。过去的做法通常是：监控系统通过某种手段（比如ping）定时检测每个机器，或者每个机器自己定时向监控系统汇报“我还活着”。 这种做法可行，但是存在两个比较明显的问题：</li></ul><p><strong>集群中机器有变动的时候，牵连修改的东西比较多。</strong></p><p><strong>有一定的延时。</strong></p><p>利用ZooKeeper有两个特性，就可以实时另一种集群机器存活性监控系统：</p><ul><li>客户端在节点 x 上注册一个Watcher，那么如果 x?的子节点变化了，会通知该客户端。</li><li>创建EPHEMERAL类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失。<br>例如，监控系统在 &#x2F;clusterServers 节点上注册一个Watcher，以后每动态加机器，那么就往 &#x2F;clusterServers 下创建一个 EPHEMERAL类型的节点：&#x2F;clusterServers&#x2F;{hostname}. 这样，监控系统就能够实时知道机器的增减情况，至于后续处理就是监控系统的业务了。</li><li>Master选举则是zookeeper中最为经典的应用场景了</li></ul><p>在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I&#x2F;O处理），往往只需要让整个集群中的某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能，于是这个master选举便是这种场景下的碰到的主要问题。</p><p>利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 &#x2F;currentMaster 节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选取了。</p><p>另外，这种场景演化一下，就是动态Master选举。这就要用到?EPHEMERAL_SEQUENTIAL类型节点的特性了。</p><p>上文中提到，所有客户端创建请求，最终只有一个能够创建成功。在这里稍微变化下，就是允许所有请求都能够创建成功，但是得有个创建顺序，于是所有的请求最终在ZK上创建结果的一种可能情况是这样： &#x2F;currentMaster&#x2F;{sessionId}-1 ,?&#x2F;currentMaster&#x2F;{sessionId}-2 ,?&#x2F;currentMaster&#x2F;{sessionId}-3 ….. 每次选取序列号最小的那个机器作为Master，如果这个机器挂了，由于他创建的节点会马上小时，那么之后最小的那个机器就是Master了。</p><ul><li>在搜索系统中，如果集群中每个机器都生成一份全量索引，不仅耗时，而且不能保证彼此之间索引数据一致。因此让集群中的Master来进行全量索引的生成，然后同步到集群中其它机器。另外，Master选举的容灾措施是，可以随时进行手动指定master，就是说应用在zk在无法获取master信息时，可以通过比如http方式，向一个地方获取master。</li><li>在Hbase中，也是使用ZooKeeper来实现动态HMaster的选举。在Hbase实现中，会在ZK上存储一些ROOT表的地址和HMaster的地址，HRegionServer也会把自己以临时节点（Ephemeral）的方式注册到Zookeeper中，使得HMaster可以随时感知到各个HRegionServer的存活状态，同时，一旦HMaster出现问题，会重新选举出一个HMaster来运行，从而避免了HMaster的单点问题</li></ul><h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p>分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强一致性。锁服务可以分为两类，一个是<strong>保持独占</strong>，<strong>另一个是控制时序</strong>。</p><p><strong>所谓保持独占</strong>，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 &#x2F;distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。</p><p><strong>控制时序</strong>，就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 &#x2F;distribute_lock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。Zk的父节点（&#x2F;distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p><h5 id="分布式队列-1"><a href="#分布式队列-1" class="headerlink" title="分布式队列"></a>分布式队列</h5><p>队列方面，简单地讲有两种，<strong>一种是常规的先进先出队列</strong>，<strong>另一种是要等到队列成员聚齐之后的才统一按序执行。</strong></p><p><del>对于第一种先进先出队列，和分布式锁服务中的控制时序场景基本原理一致，这里不再赘述。</del></p><p><strong>第二种队列其实是在FIFO队列的基础上作了一个增强。</strong></p><p>通常可以在 &#x2F;queue 这个znode下预先建立一个&#x2F;queue&#x2F;num 节点，并且赋值为n（或者直接给&#x2F;queue赋值n），表示队列大小，之后每次有队列成员加入后，就判断下是否已经到达队列大小，决定是否可以开始执行了。这种用法的典型场景是，分布式环境中，一个大任务Task A，需要在很多子任务完成（或条件就绪）情况下才能进行。这个时候，凡是其中一个子任务完成（就绪），那么就去 &#x2F;taskList 下建立自己的临时时序节点（CreateMode.EPHEMERAL_SEQUENTIAL），当 &#x2F;taskList 发现自己下面的子节点满足指定个数，就可以进行下一步按序进行处理了。</p><hr><h5 id="etcd-vs-Zookeeper"><a href="#etcd-vs-Zookeeper" class="headerlink" title="etcd vs. Zookeeper?"></a>etcd vs. Zookeeper?</h5><p>etcd能实现的Zookeeper都能实现，但是<strong>与etcd相比Zookeeper有如下缺点：</strong></p><ul><li>复杂 Zookeeper的部署维护复杂，而Paxos强一致性算法也素来以复杂闻名于世；另外Zookeeper使用也比较复杂，需要安装客户端，官方只提供了java和c两种语言的接口。</li><li>Java编写 java本身偏重于重型应用，他会引入大量依赖</li><li>发展缓慢</li></ul><p><strong>而etcd作为后起之秀，优点明显：</strong></p><ul><li>简单</li><li>数据持久化 etcd默认数据一更新就进行持久化</li><li>安全</li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于docker的rabbitmq集群</title>
    <link href="/Docker/Docker-RabbitMQ/"/>
    <url>/Docker/Docker-RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h3 id="架构简介"><a href="#架构简介" class="headerlink" title="架构简介"></a>架构简介</h3><p><img src="/Docker/Docker-RabbitMQ/%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B.png" alt="架构简介"></p><h3 id="安装基于docker的rabbitmq"><a href="#安装基于docker的rabbitmq" class="headerlink" title="安装基于docker的rabbitmq"></a>安装基于docker的rabbitmq</h3><h4 id="安装rabbitMQ"><a href="#安装rabbitMQ" class="headerlink" title="安装rabbitMQ"></a>安装rabbitMQ</h4><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">docker run -d <span class="hljs-attr">--hostname</span> rabbit1 <span class="hljs-attr">--name</span> rabbit1 -<span class="hljs-selector-tag">p</span> <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span>  -e RABBITMQ_ERLANG_COOKIE=<span class="hljs-string">&#x27;rabbitmq&#x27;</span> rabbitmq:<span class="hljs-number">3</span><br><br>docker run -d <span class="hljs-attr">--hostname</span> rabbit2 <span class="hljs-attr">--name</span> rabbit2 -<span class="hljs-selector-tag">p</span> <span class="hljs-number">5673</span>:<span class="hljs-number">5672</span> <span class="hljs-attr">--link</span> rabbit1:rabbit1 -e RABBITMQ_ERLANG_COOKIE=<span class="hljs-string">&#x27;rabbitmq&#x27;</span> rabbitmq:<span class="hljs-number">3</span><br><br>docker run -d <span class="hljs-attr">--hostname</span> rabbit3 <span class="hljs-attr">--name</span> rabbit3 -<span class="hljs-selector-tag">p</span> <span class="hljs-number">5674</span>:<span class="hljs-number">5672</span> <span class="hljs-attr">--link</span> rabbit1:rabbit1 <span class="hljs-attr">--link</span> rabbit2:rabbit2 -e RABBITMQ_ERLANG_COOKIE=<span class="hljs-string">&#x27;rabbitmq&#x27;</span> rabbitmq:<span class="hljs-number">3</span><br><br>注意RABBITMQ_ERLANG_COOKIE必须一样的,可以自定义.<br></code></pre></td></tr></table></figure><h4 id="连接到rabbit1执行操作"><a href="#连接到rabbit1执行操作" class="headerlink" title="连接到rabbit1执行操作"></a>连接到rabbit1执行操作</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl">docker <span class="hljs-keyword">exec</span> -it rabbit1 bash<br>rabbitmqctl stop_app<br>rabbitmqctl <span class="hljs-keyword">reset</span><br>rabbitmqctl start_app<br><br>此时的集群情况:<br>root@rabbit1:/<span class="hljs-comment"># rabbitmqctl cluster_status</span><br>Cluster status of node rabbit@rabbit1 ...<br>[&#123;nodes,[&#123;disc,[rabbit@rabbit1]&#125;]&#125;,<br> &#123;running_nodes,[rabbit@rabbit1]&#125;,<br> &#123;cluster_name,&lt;&lt;<span class="hljs-string">&quot;rabbit@rabbit1&quot;</span>&gt;&gt;&#125;,<br> &#123;partitions,[]&#125;,<br> &#123;alarms,[&#123;rabbit@rabbit1,[]&#125;]&#125;]<br></code></pre></td></tr></table></figure><h4 id="连接到rabbit2-将他加入到rabbit1的集群"><a href="#连接到rabbit2-将他加入到rabbit1的集群" class="headerlink" title="连接到rabbit2,将他加入到rabbit1的集群"></a>连接到rabbit2,将他加入到rabbit1的集群</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl">docker <span class="hljs-keyword">exec</span> -it rabbit2 bash<br> rabbitmqctl stop_app<br> rabbitmqctl <span class="hljs-keyword">reset</span><br> rabbitmqctl join_cluster rabbit@rabbit1<br> rabbitmqctl start_app<br> 此时可以查看集群的情况:<br> rabbitmqctl cluster_status<br>Cluster status of node rabbit@rabbit2 ...<br>[&#123;nodes,[&#123;disc,[rabbit@rabbit1,rabbit@rabbit2]&#125;]&#125;,<br> &#123;running_nodes,[rabbit@rabbit1,rabbit@rabbit2]&#125;,<br> &#123;cluster_name,&lt;&lt;<span class="hljs-string">&quot;rabbit@rabbit1&quot;</span>&gt;&gt;&#125;,<br>&#123;partitions,[]&#125;,<br> &#123;alarms,[&#123;rabbit@rabbit1,[]&#125;,&#123;rabbit@rabbit2,[]&#125;]&#125;]<br></code></pre></td></tr></table></figure><h4 id="连接到rabbit3-将他加入到rabbit1的集群"><a href="#连接到rabbit3-将他加入到rabbit1的集群" class="headerlink" title="连接到rabbit3,将他加入到rabbit1的集群"></a>连接到rabbit3,将他加入到rabbit1的集群</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl">docker <span class="hljs-keyword">exec</span> -it rabbit3 bash<br> rabbitmqctl stop_app<br> rabbitmqctl <span class="hljs-keyword">reset</span><br> rabbitmqctl join_cluster rabbit@rabbit1<br> rabbitmqctl start_app<br> 此时可以查看集群的情况:<br> rabbitmqctl cluster_status<br> Cluster status of node rabbit@rabbit3 ...<br>[&#123;nodes,[&#123;disc,    [rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;]&#125;,<br> &#123;running_nodes,    [rabbit@rabbit1,rabbit@rabbit2,rabbit@rabbit3]&#125;,<br> &#123;cluster_name,&lt;&lt;<span class="hljs-string">&quot;rabbit@rabbit1&quot;</span>&gt;&gt;&#125;,<br> &#123;partitions,[]&#125;,<br> &#123;alarms,[&#123;rabbit@rabbit1,[]&#125;,&#123;rabbit@rabbit2,[]&#125;,    &#123;rabbit@rabbit3,[]&#125;]&#125;]    <br></code></pre></td></tr></table></figure><h4 id="配置HAProxy-实现负载均衡"><a href="#配置HAProxy-实现负载均衡" class="headerlink" title="配置HAProxy,实现负载均衡"></a>配置HAProxy,实现负载均衡</h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs smali">global<br>log 127.0.0.1 local0 info<br>maxconn 4096<br>daemon<br><br>defaults<br>    log global<br>    mode tcp<br>    option tcplog<br>    option dontlognull<br>    retries 3<br>    option redispatch<br>    maxconn 300<br>    timeout connect 5s<br>    timeout client 120s<br>    timeout server 120s<br><br>listen rabbitmq_local_cluster<br>    bind  127.0.0.1:5670<br>    mode tcp<br>    balance roundrobin<br>    server rabbit_1 127.0.0.1:5672<span class="hljs-built_in"> check </span>inter 5000 rise 2 fall 3<br>    server rabbit_2 127.0.0.1:5673<span class="hljs-built_in"> check </span>inter 5000 rise 2 fall 3<br>    server rabbit_3 127.0.0.1:5674<span class="hljs-built_in"> check </span>inter 5000 rise 2 fall 3<br><br>listen<span class="hljs-keyword"> private</span>_monitoring<br>    bind 127.0.0.1:8100<br>    mode http<br>    option httplog<br>    stats enable<br>    stats uri /stats<br>    stats refresh 5s    <br></code></pre></td></tr></table></figure><h4 id="启动haproxy"><a href="#启动haproxy" class="headerlink" title="启动haproxy"></a>启动haproxy</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">haproxy -f conf</span><br></code></pre></td></tr></table></figure><h4 id="在浏览器输入http-localhost-8100-stats-查看结果"><a href="#在浏览器输入http-localhost-8100-stats-查看结果" class="headerlink" title="在浏览器输入http://localhost:8100/stats,查看结果."></a>在浏览器输入<a href="http://localhost:8100/stats,%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C">http://localhost:8100/stats,查看结果</a>.</h4><p><img src="/Docker/Docker-RabbitMQ/%E7%BB%93%E6%9E%9C.png" alt="结果"></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负载均衡之dns轮询</title>
    <link href="/DNS/DNS-polling-for-load-balancing/"/>
    <url>/DNS/DNS-polling-for-load-balancing/</url>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>大多数域名注册商都支持对统一主机添加多条A记录，这就是DNS轮询，DNS服务器将解析请求按照A记录的顺序，随机分配到不同的IP上，这样就完成了简单的负载均衡。下图的例子是：有3台联通服务器、3台电信服务器，要实现“联通用户流量分摊到3台联通服务器、其他用户流量分摊到电信服务器”这个效果的设置。</p><p><img src="/DNS/DNS-polling-for-load-balancing/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE.png" alt="域名解析配置"></p><p>DNS由于成本较低，所以一般在小型的网站用的比较多。但是大型的网站一般也会将用它和其他负载均衡的方式结合起来一起使用，DNS轮询方式提供的IP地址，在大型网站中往往是一个集群的地址，可能是均衡交换机也可能是均衡服务器。对于小网站的话，挂接多台服务器也没有问题。如：</p><p><img src="/DNS/DNS-polling-for-load-balancing/nslookup%E7%99%BE%E5%BA%A6.png" alt="nslookup百度"></p><h4 id="DNS轮询的优点"><a href="#DNS轮询的优点" class="headerlink" title="DNS轮询的优点"></a>DNS轮询的优点</h4><ol><li>零成本：只是在DNS服务器上绑定几个A记录，域名注册商一般都免费提供解析服务；</li><li>部署简单：就是在网络拓扑进行设备扩增，然后在DNS服务器上添加记录。</li></ol><h4 id="DNS轮询的缺点"><a href="#DNS轮询的缺点" class="headerlink" title="DNS轮询的缺点"></a>DNS轮询的缺点</h4><ul><li>可靠性低</li></ul><p>假设一个域名DNS轮询多台服务器，如果其中的一台服务器发生故障，那么所有的访问该服务器的请求将不会有所回应，这是任何人都不愿意看到的。即使从DNS中去掉该服务器的IP，但在Internet上，各地区电信、网通等宽带接入商将众多的DNS存放在缓存中，以节省访问时间，DNS记录全部生效需要几个小时，甚至更久。所以，尽管DNS轮询在一定程度上解决了负载均衡问题，但是却存在可靠性不高的缺点。</p><ul><li>负载分配不均匀</li></ul><p>DNS负载均衡采用的是简单的轮询算法，不能区分服务器的差异，不能反映服务器的当前运行状态，不能做到为性能较好的服务器多分配请求，甚至会出现客户请求集中在某一台服务器上的情况。</p><p>DNS服务器是按照一定的层次结构组织的，本地DNS服务器会缓存已解析的域名到IP地址的映射，这会导致使用该DNS服务器的用户在一段时间内访问的是同一台Web服务器，导致Web服务器间的负载不均匀。此外，用户本地计算机也会缓存已解析的域名到IP地址的映射。当多个用户计算机都缓存了某个域名到IP地址的映射时，而这些用户又继续访问该域名下的网页，这时也会导致不同Web服务器间的负载分配不均匀。</p><p>负载不均匀可能导致的后果有：某几台服务器负荷很低，而另几台服务器负载很高、处理缓慢；配置高的服务器分配到的请求少，而配置低的服务器分配到的请求多。</p><h4 id="可靠性底的解决方案"><a href="#可靠性底的解决方案" class="headerlink" title="可靠性底的解决方案"></a>可靠性底的解决方案</h4><ul><li>架构图</li></ul><p><img src="/DNS/DNS-polling-for-load-balancing/%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="架构图"></p><ul><li><p>具体步骤</p><p>实现域名的解析,获取域名所有的A记录解析IP列表,对IP列表进行HTTP级别的探测</p></li><li><p>代码实现</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><pre><code class="hljs python">[dns_loop.py] []<span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">import</span> dns.resolver<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> httplib<br><br>iplist = []<br>appdomain=<span class="hljs-string">&quot;admin888.yinmimoney.com&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_iplist</span>(<span class="hljs-params">domain=<span class="hljs-string">&quot;&quot;</span></span>):<br>    <span class="hljs-keyword">try</span>:<br>        A = dns.resolver.query(domain,<span class="hljs-string">&#x27;A&#x27;</span>)<br>    <span class="hljs-keyword">except</span> Exception,e:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;dns resolver error:&quot;</span>+<span class="hljs-built_in">str</span>(e)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> A.response.answer:<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i.items:<br>            iplist.append(j.address)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">checkip</span>(<span class="hljs-params">ip</span>):<br>    checkurl = ip+<span class="hljs-string">&quot;:80&quot;</span><br>    getcontent = <span class="hljs-string">&quot;&quot;</span><br>    httplib.socket.setdefaulttimeout(<span class="hljs-number">5</span>)<br>    conn = httplib.HTTPConnection(checkurl)<br><br>    <span class="hljs-keyword">try</span>:<br>        conn.request(<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;/admin/login&quot;</span>,headers = &#123;<span class="hljs-string">&quot;Host&quot;</span>:appdomain&#125;)<br>        r = conn.getresponse()<br>        getcontent = r.read(<span class="hljs-number">15</span>)<br>    <span class="hljs-keyword">except</span> Exception,e:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;checkip &quot;</span>+ip+<span class="hljs-string">&quot; error:&quot;</span>+<span class="hljs-built_in">str</span>(e)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">if</span> getcontent == <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;&quot;</span>:<br>            <span class="hljs-built_in">print</span> ip + <span class="hljs-string">&quot; [OK]&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span> ip + <span class="hljs-string">&quot; [Error] &quot;</span>+ getcontent<br><br><span class="hljs-keyword">if</span>  __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">if</span> get_iplist(appdomain) <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(iplist)&gt;<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> iplist:<br>            checkip(ip)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;dns resolver error.&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DNS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Load Balance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS解析之A和CNAME</title>
    <link href="/DNS/DNS-A-and-CNAME/"/>
    <url>/DNS/DNS-A-and-CNAME/</url>
    
    <content type="html"><![CDATA[<h3 id="A与CNAME的区别"><a href="#A与CNAME的区别" class="headerlink" title="A与CNAME的区别"></a>A与CNAME的区别</h3><p>A记录是域名到ip的映射，即为ip起别名；CNAME是域名别名到域名的映射，即为域名起别名。还有一个常用的记录是MX记录，它是与邮件相关的，MX记录记录了发送电子邮件时域名对应的服务器地址。</p><h4 id="什么是域名解析"><a href="#什么是域名解析" class="headerlink" title="什么是域名解析"></a>什么是域名解析</h4><p>域名解析就是国际域名或者国内域名以及中文域名等域名申请后做的到IP地址的转换过程。IP地址是网路上标识您站点的数字地址，为了简单好记，采用域名来代替ip地址标识站点地址。域名的解析工作由DNS服务器完成。</p><h4 id="什么是A记录"><a href="#什么是A记录" class="headerlink" title="什么是A记录"></a>什么是A记录</h4><p>A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。</p><h4 id="什么是CNAME记录"><a href="#什么是CNAME记录" class="headerlink" title="什么是CNAME记录"></a>什么是CNAME记录</h4><p>即：别名记录。这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。这两个别名的全称就 <a href="http://www.mydomain.com/%E5%92%8C%E2%80%9Cmail.mydomain.com%E2%80%9D%E3%80%82%E5%AE%9E%E9%99%85%E4%B8%8A%E4%BB%96%E4%BB%AC%E9%83%BD%E5%90%91%E2%80%9Chost.mydomain.com%E2%80%9D%E3%80%82">http://www.mydomain.com/和“mail.mydomain.com”。实际上他们都向“host.mydomain.com”。</a></p><h4 id="使用A记录和CNAME进行域名解析的区别"><a href="#使用A记录和CNAME进行域名解析的区别" class="headerlink" title="使用A记录和CNAME进行域名解析的区别"></a>使用A记录和CNAME进行域名解析的区别</h4><p>A记录就是把一个域名解析到一个IP地址（Address，特制数字IP地址），而CNAME记录就是把域名解析到另外一个域名。其功能是差不多，CNAME将几个主机名指向一个别名，其实跟指向IP地址是一样的，因为这个别名也要做一个A记录的。但是使用CNAME记录可以很方便地变更IP地址。如果一台服务器有100个网站，他们都做了别名，该台服务器变更IP时，只需要变更别名的A记录就可以了。</p><h4 id="使用A记录和CNAME哪个好"><a href="#使用A记录和CNAME哪个好" class="headerlink" title="使用A记录和CNAME哪个好"></a>使用A记录和CNAME哪个好</h4><p>域名解析CNAME记录A记录哪一种比较好？如果论对网站的影响，就没有多大区别。但是：CNAME有一个好处就是稳定，就好像一个IP与一个域名的区别。服务商从方便维护的角度，一般也建议用户使用CNAME记录绑定域名的。如果主机使用了双线IP，显然使用CNAME也要方便一些。</p><p>A记录也有一些好处，例如可以在输入域名时不用输入WWW.来访问网站哦！从SEO优化角度来看，一些搜索引擎如alex或一些搜索查询工具网站等等则默认是自动去掉WWW.来辨别网站，CNAME记录是必须有如：WWW(别名)前缀的域名，有时候会遇到这样的麻烦，前缀去掉了默认网站无法访问。<br>有人认为，在SEO优化网站的时候，由于搜索引擎找不到去掉WWW.的域名时，对网站权重也会有些影响。因为有些网民客户也是不喜欢多写三个W来访问网站的，网站无法访问有少量网民客户会放弃继续尝试加WWW.访问域名了，因此网站访问浏览量也会减少一些。<br>也有人认为同一个域名加WWW.和不加WWW.访问网站也会使网站权重分散，这也是个问题。但是可以使用301跳转把不加WWW.跳转到加WWW.的域名，问题就解决了。</p>]]></content>
    
    
    <categories>
      
      <category>DNS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>A</tag>
      
      <tag>CNAME</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库分库分表</title>
    <link href="/Database/Database-Splits/"/>
    <url>/Database/Database-Splits/</url>
    
    <content type="html"><![CDATA[<h3 id="基本方案"><a href="#基本方案" class="headerlink" title="基本方案"></a>基本方案</h3><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p>垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中.如下图所示:</p><p><img src="/Database/Database-Splits/%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8.png" alt="垂直分表"></p><p>在字段很多的情况下，拆分开确实更便于开发和维护。某种意义上也能避免“跨页”的问题.拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。</p><h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h4><p>垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。如下图：</p><p><img src="/Database/Database-Splits/%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93.png" alt="垂直分库"></p><p>系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。</p><p>众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。</p><p>然而，很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。</p><h4 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h4><p>水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。如下图所示：</p><p><img src="/Database/Database-Splits/%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8.png" alt="水平分表"></p><p>水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，一般不建议采用这种做法。</p><h4 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h4><p>水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据中。这也是很多大型互联网公司所选择的做法。如下图：</p><p><img src="/Database/Database-Splits/%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.png" alt="水平分库分表"></p><p>某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）</p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择的力量</title>
    <link href="/Life/Choise-Power/"/>
    <url>/Life/Choise-Power/</url>
    
    <content type="html"><![CDATA[<p><strong>“自由”到一无所有，我沦为劳动力，“必然”到放不开手，我停步不前。</strong></p><p>作为现实的人，我多想在我的可能性空间里选择自己，创造自己的历史，可是我的可能性空间在哪？他有多大？</p><p>他们说你可以应用选择力量——人类最伟大的力量。</p><p>那样你的可能性空间要多大有多大，是啊，这绝对不是唯心主义，他是在重视人类情感因素的力量，并把他发挥到极致，把握自由与必然的度，当你消沉的时候，想想你的未来，他是多么美好，当你轻浮的时候，立足现在，美好的未来靠现在的拼搏！</p><p>发挥好选择的力量，你会应有尽有！</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax基础</title>
    <link href="/Javascript/Ajax-Basic/"/>
    <url>/Javascript/Ajax-Basic/</url>
    
    <content type="html"><![CDATA[<h3 id="Ajax简介"><a href="#Ajax简介" class="headerlink" title="Ajax简介"></a>Ajax简介</h3><p>ajax技术的核心是XMLHttpRequest对象(简称XHR),她使用户不需要刷新页面就能从<br>服务器获取数据.代码地址<a href="https://github.com/ivivisoft/ajax">github</a></p><h3 id="Ajax的使用方法"><a href="#Ajax的使用方法" class="headerlink" title="Ajax的使用方法"></a>Ajax的使用方法</h3><h4 id="获取XMLHttpRequest对象"><a href="#获取XMLHttpRequest对象" class="headerlink" title="获取XMLHttpRequest对象"></a>获取XMLHttpRequest对象</h4><p>正常情况下只需要 new XMLHttpRequest()即可,但是要兼容IE7以前的浏览器,则需<br>要做一些额外的操作,index.js文件中的createXHR()方法就是做了这些事情.</p><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>发送请求包括同步请求和异步请求.</p><p>同步请求一般步骤:</p><ol><li><p>使用xhr的open方法,open方法第一个参数表示调用方法的方式get,post等,第二个参<br>数表示URL地址,第三个参数表示是否异步发送,false表示否,true表示异步发送.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs livecodeserver">注意!此处的<span class="hljs-built_in">URL</span>只能向同一个域中使用相同端口和协议的<span class="hljs-built_in">URL</span>发送请求,<br>否则存在跨域问题.<br></code></pre></td></tr></table></figure></li><li><p>使用send方法发送请求,send方法接受一个参数,既要作为请求主体发送的数据,如果不<br>需要参数,一定要传null.</p></li><li><p>返回结果:响应返回的结果会自动的填充到xhr对象上:</p><ul><li>responseText:作为响应主体返回的文本</li><li>responseXML:如果响应的内容类型是”text&#x2F;xml”或”application&#x2F;xml”,这个<br>属性中将保存包含着响应数据的XML DOM文档,对于非xml的响应,其为null</li><li>status:响应的HTTP状态,200表示成功,304表示服务端数据没有改变,可以使用浏览<br>器缓存中的数据</li><li>statusText:HTTP状态说明</li></ul></li></ol><p>异步请求:<br>异步方式依赖于XHR对象的readyState属性,她表示请求&#x2F;响应过程的当前活动阶段,取值如下:</p><ul><li><p>0:未初始化.尚未调用open()方法</p></li><li><p>1:启动.已经调用open方法,但尚未调用send方法</p></li><li><p>2:发送.已经调用send方法,但尚未接收到响应</p></li><li><p>3:接收.已经接收到部分响应数据</p></li><li><p>4:完成.已经接收全部响应数据,而且已经可以在客户端使用了</p><p>注意!onreadystatechange的函数没有使用this对象,<br>原因是onreadystatechange事件处理的作用域问题.如果使用<br>this对象在有的浏览器会执行失败,或者导致错误.所以使用实际<br>的XHR对象实例变量是较为可靠的一种方式.另外在接收到响应之<br>前,可以调用xhr.abort()来取消异步请求</p></li></ul><h4 id="HTTP头信息说明"><a href="#HTTP头信息说明" class="headerlink" title="HTTP头信息说明"></a>HTTP头信息说明</h4><p>在默认情况下,在发送XHR请求时,还会发送下列头部信息:</p><ul><li><p>Accept:浏览器能够处理的内容类型</p></li><li><p>Accept-Charset:浏览器能够显示的字符集</p></li><li><p>Accept-Encoding:浏览器能够处理的压缩编码</p></li><li><p>Accept-Language:浏览器当前设置的语言</p></li><li><p>Connection:浏览器与服务器之间连接的类型</p></li><li><p>Cookie:当前页面设置的任何Cookie</p></li><li><p>Host:发送请求的页面所在的域</p></li><li><p>Referer:发送请求的页面URI</p></li><li><p>User-Agent:浏览器的用户代理字符串</p></li><li><p>使用setRequestHeader可以设置自定义的请求头部,她接收两个参数,<br>第一个是头部的名称,后面一个是头部字段的值.</p><p>注意!要成功发送请求头部信息,必须在调用open方法之后且<br>调用send方法之前,调用setRequestHeader方法.设置的头<br>部名称的值不要和默认发送的一样,会导致错误.</p></li></ul><h4 id="GET请求说明"><a href="#GET请求说明" class="headerlink" title="GET请求说明"></a>GET请求说明</h4><p>GET请求要把查询字符串添加到URL后面,以便传给服务器.对于XHR而言,位于传入open方法的URL末尾的查询字符串必须经过正确的编码才行.index.js中提供了一个简单的方法addURLParam()实现了这个功能</p><h4 id="POST请求说明"><a href="#POST请求说明" class="headerlink" title="POST请求说明"></a>POST请求说明</h4><p>由于XHR最初设计主要是为了处理XML的,因此可以传入XML DOM文档,传入的文档经序列化之后将作<br>为请求主体被提交到服务器.当然也可以传入任何想传给服务器的字符串<br>注意!默认情况下,服务器对POST请求和提交web表单的请求并不会一视同仁.因此服务器端必须有程序<br>来读取发送过来的原始数据,并解析出有用的部分.不过我们可以使用XHR来模仿表单提交:</p><ol><li>首先将Content-Type头部信息设置为application&#x2F;x-www-form-urlencoded.</li><li>以适当的格式创建一个字符串.也就是表单数据序列化.</li></ol><p>针对于Ajax,POST请求带来的一个问题就是表单序列化.<br>先看一下,在表单提交期间,浏览器是怎样将数据发送给服务器的:</p><ol><li>对表单字段的名称和值进行URL编码,使用和号(&amp;)分割.</li><li>不发送禁用的表单字段</li><li>只发送勾选的复选框和单选按钮</li><li>不要发送type为”reset”和”button”的按钮</li><li>多选选择框的每个选中的值单独一个条目.</li><li>在单击提交按钮提交表单的情况下,也会发送提交按钮;否则不发送提交按钮.也包括type为”image”的input元素</li><li>select元素的值,就是选中的option元素的value特性的值.如果option元素没有value特性,则是option元素的文本值index.js的serialize方法提供了form表单的序列化功能.</li></ol><h4 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h4><p>form表单中的button如果不指定type类型,默认为submit类型,会触发表单提交,解决方法有两种:</p><ol><li>指定type为button</li><li>onclick事件上加return false;</li></ol>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
